// DO NOT EDIT!
// Auto generated by scripts/protoc-gen-grpcwrapper

namespace MurmurRPC {
namespace Wrapper {

class V1_GetUptime : public RPCSingleSingleCall< ::MurmurRPC::Void, ::MurmurRPC::Uptime > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_GetUptime(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_GetUptime::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_GetUptime::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_GetUptime(rpc, service);
		auto fn = ::boost::bind(&V1_GetUptime::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetUptime(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_GetVersion : public RPCSingleSingleCall< ::MurmurRPC::Void, ::MurmurRPC::Version > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_GetVersion(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_GetVersion::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_GetVersion::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_GetVersion(rpc, service);
		auto fn = ::boost::bind(&V1_GetVersion::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetVersion(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_Events : public RPCSingleStreamCall< ::MurmurRPC::Void, ::MurmurRPC::Event > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_Events(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleStreamCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	::boost::function<void(bool)> *callback(::boost::function<void(V1_Events *, bool)> cb) {
		auto fn = ::boost::bind(&V1_Events::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void handle(bool ok) {
		V1_Events::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_Events::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_Events(rpc, service);
		auto fn = ::boost::bind(&V1_Events::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestEvents(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(V1_Events *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};

class V1_ServerCreate : public RPCSingleSingleCall< ::MurmurRPC::Void, ::MurmurRPC::Server > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ServerCreate(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ServerCreate::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ServerCreate::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ServerCreate(rpc, service);
		auto fn = ::boost::bind(&V1_ServerCreate::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestServerCreate(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ServerQuery : public RPCSingleSingleCall< ::MurmurRPC::Server_Query, ::MurmurRPC::Server_List > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ServerQuery(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ServerQuery::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ServerQuery::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ServerQuery(rpc, service);
		auto fn = ::boost::bind(&V1_ServerQuery::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestServerQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ServerGet : public RPCSingleSingleCall< ::MurmurRPC::Server, ::MurmurRPC::Server > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ServerGet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ServerGet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ServerGet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ServerGet(rpc, service);
		auto fn = ::boost::bind(&V1_ServerGet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestServerGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ServerStart : public RPCSingleSingleCall< ::MurmurRPC::Server, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ServerStart(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ServerStart::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ServerStart::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ServerStart(rpc, service);
		auto fn = ::boost::bind(&V1_ServerStart::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestServerStart(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ServerStop : public RPCSingleSingleCall< ::MurmurRPC::Server, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ServerStop(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ServerStop::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ServerStop::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ServerStop(rpc, service);
		auto fn = ::boost::bind(&V1_ServerStop::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestServerStop(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ServerRemove : public RPCSingleSingleCall< ::MurmurRPC::Server, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ServerRemove(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ServerRemove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ServerRemove::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ServerRemove(rpc, service);
		auto fn = ::boost::bind(&V1_ServerRemove::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestServerRemove(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ServerEvents : public RPCSingleStreamCall< ::MurmurRPC::Server, ::MurmurRPC::Server_Event > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ServerEvents(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleStreamCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	::boost::function<void(bool)> *callback(::boost::function<void(V1_ServerEvents *, bool)> cb) {
		auto fn = ::boost::bind(&V1_ServerEvents::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void handle(bool ok) {
		V1_ServerEvents::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ServerEvents::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ServerEvents(rpc, service);
		auto fn = ::boost::bind(&V1_ServerEvents::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestServerEvents(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(V1_ServerEvents *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};

class V1_ContextActionAdd : public RPCSingleSingleCall< ::MurmurRPC::ContextAction, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ContextActionAdd(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ContextActionAdd::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ContextActionAdd::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ContextActionAdd(rpc, service);
		auto fn = ::boost::bind(&V1_ContextActionAdd::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestContextActionAdd(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ContextActionRemove : public RPCSingleSingleCall< ::MurmurRPC::ContextAction, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ContextActionRemove(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ContextActionRemove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ContextActionRemove::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ContextActionRemove(rpc, service);
		auto fn = ::boost::bind(&V1_ContextActionRemove::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestContextActionRemove(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ContextActionEvents : public RPCSingleStreamCall< ::MurmurRPC::ContextAction, ::MurmurRPC::ContextAction > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ContextActionEvents(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleStreamCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	::boost::function<void(bool)> *callback(::boost::function<void(V1_ContextActionEvents *, bool)> cb) {
		auto fn = ::boost::bind(&V1_ContextActionEvents::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void handle(bool ok) {
		V1_ContextActionEvents::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ContextActionEvents::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ContextActionEvents(rpc, service);
		auto fn = ::boost::bind(&V1_ContextActionEvents::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestContextActionEvents(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(V1_ContextActionEvents *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};

class V1_TextMessageSend : public RPCSingleSingleCall< ::MurmurRPC::TextMessage, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_TextMessageSend(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_TextMessageSend::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_TextMessageSend::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_TextMessageSend(rpc, service);
		auto fn = ::boost::bind(&V1_TextMessageSend::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestTextMessageSend(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_TextMessageFilter : public RPCStreamStreamCall< ::MurmurRPC::TextMessage_Filter, ::MurmurRPC::TextMessage_Filter > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_TextMessageFilter(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCStreamStreamCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	bool write() {
		bool processed = false;
		bool success;
		auto cb = [&success, &processed] (V1_TextMessageFilter *, bool ok) {
			success = ok;
			processed = true;
		};
		stream.Write(response, callback(cb));
		while (!processed) {
			QCoreApplication::processEvents(QEventLoop::ExcludeSocketNotifiers, 100);
		}
		return success;
	}

	bool read() {
		bool processed = false;
		bool success;
		auto cb = [&success, &processed] (V1_TextMessageFilter *, bool ok) {
			success = ok;
			processed = true;
		};
		stream.Read(&request, callback(cb));
		while (!processed) {
			QCoreApplication::processEvents(QEventLoop::ExcludeSocketNotifiers, 100);
		}
		return success;
	}

	bool writeRead() {
		return write() && read();
	}

	::boost::function<void(bool)> *callback(::boost::function<void(V1_TextMessageFilter *, bool)> cb) {
		auto fn = ::boost::bind(&V1_TextMessageFilter::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void handle(bool ok) {
		V1_TextMessageFilter::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_TextMessageFilter::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_TextMessageFilter(rpc, service);
		auto fn = ::boost::bind(&V1_TextMessageFilter::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestTextMessageFilter(&call->context, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(V1_TextMessageFilter *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};

class V1_LogQuery : public RPCSingleSingleCall< ::MurmurRPC::Log_Query, ::MurmurRPC::Log_List > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_LogQuery(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_LogQuery::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_LogQuery::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_LogQuery(rpc, service);
		auto fn = ::boost::bind(&V1_LogQuery::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestLogQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ConfigGet : public RPCSingleSingleCall< ::MurmurRPC::Server, ::MurmurRPC::Config > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ConfigGet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ConfigGet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ConfigGet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ConfigGet(rpc, service);
		auto fn = ::boost::bind(&V1_ConfigGet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestConfigGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ConfigGetField : public RPCSingleSingleCall< ::MurmurRPC::Config_Field, ::MurmurRPC::Config_Field > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ConfigGetField(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ConfigGetField::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ConfigGetField::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ConfigGetField(rpc, service);
		auto fn = ::boost::bind(&V1_ConfigGetField::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestConfigGetField(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ConfigSetField : public RPCSingleSingleCall< ::MurmurRPC::Config_Field, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ConfigSetField(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ConfigSetField::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ConfigSetField::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ConfigSetField(rpc, service);
		auto fn = ::boost::bind(&V1_ConfigSetField::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestConfigSetField(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ConfigGetDefault : public RPCSingleSingleCall< ::MurmurRPC::Void, ::MurmurRPC::Config > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ConfigGetDefault(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ConfigGetDefault::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ConfigGetDefault::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ConfigGetDefault(rpc, service);
		auto fn = ::boost::bind(&V1_ConfigGetDefault::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestConfigGetDefault(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ChannelQuery : public RPCSingleSingleCall< ::MurmurRPC::Channel_Query, ::MurmurRPC::Channel_List > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ChannelQuery(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ChannelQuery::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ChannelQuery::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ChannelQuery(rpc, service);
		auto fn = ::boost::bind(&V1_ChannelQuery::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestChannelQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ChannelGet : public RPCSingleSingleCall< ::MurmurRPC::Channel, ::MurmurRPC::Channel > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ChannelGet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ChannelGet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ChannelGet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ChannelGet(rpc, service);
		auto fn = ::boost::bind(&V1_ChannelGet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestChannelGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ChannelAdd : public RPCSingleSingleCall< ::MurmurRPC::Channel, ::MurmurRPC::Channel > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ChannelAdd(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ChannelAdd::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ChannelAdd::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ChannelAdd(rpc, service);
		auto fn = ::boost::bind(&V1_ChannelAdd::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestChannelAdd(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ChannelRemove : public RPCSingleSingleCall< ::MurmurRPC::Channel, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ChannelRemove(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ChannelRemove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ChannelRemove::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ChannelRemove(rpc, service);
		auto fn = ::boost::bind(&V1_ChannelRemove::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestChannelRemove(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ChannelUpdate : public RPCSingleSingleCall< ::MurmurRPC::Channel, ::MurmurRPC::Channel > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ChannelUpdate(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ChannelUpdate::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ChannelUpdate::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ChannelUpdate(rpc, service);
		auto fn = ::boost::bind(&V1_ChannelUpdate::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestChannelUpdate(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_UserQuery : public RPCSingleSingleCall< ::MurmurRPC::User_Query, ::MurmurRPC::User_List > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_UserQuery(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_UserQuery::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_UserQuery::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_UserQuery(rpc, service);
		auto fn = ::boost::bind(&V1_UserQuery::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUserQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_UserGet : public RPCSingleSingleCall< ::MurmurRPC::User, ::MurmurRPC::User > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_UserGet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_UserGet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_UserGet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_UserGet(rpc, service);
		auto fn = ::boost::bind(&V1_UserGet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUserGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_UserUpdate : public RPCSingleSingleCall< ::MurmurRPC::User, ::MurmurRPC::User > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_UserUpdate(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_UserUpdate::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_UserUpdate::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_UserUpdate(rpc, service);
		auto fn = ::boost::bind(&V1_UserUpdate::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUserUpdate(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_UserKick : public RPCSingleSingleCall< ::MurmurRPC::User_Kick, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_UserKick(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_UserKick::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_UserKick::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_UserKick(rpc, service);
		auto fn = ::boost::bind(&V1_UserKick::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUserKick(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_TreeQuery : public RPCSingleSingleCall< ::MurmurRPC::Tree_Query, ::MurmurRPC::Tree > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_TreeQuery(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_TreeQuery::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_TreeQuery::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_TreeQuery(rpc, service);
		auto fn = ::boost::bind(&V1_TreeQuery::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestTreeQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_BansGet : public RPCSingleSingleCall< ::MurmurRPC::Ban_Query, ::MurmurRPC::Ban_List > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_BansGet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_BansGet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_BansGet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_BansGet(rpc, service);
		auto fn = ::boost::bind(&V1_BansGet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestBansGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_BansSet : public RPCSingleSingleCall< ::MurmurRPC::Ban_List, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_BansSet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_BansSet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_BansSet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_BansSet(rpc, service);
		auto fn = ::boost::bind(&V1_BansSet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestBansSet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ACLGet : public RPCSingleSingleCall< ::MurmurRPC::Channel, ::MurmurRPC::ACL_List > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ACLGet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ACLGet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ACLGet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ACLGet(rpc, service);
		auto fn = ::boost::bind(&V1_ACLGet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestACLGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ACLSet : public RPCSingleSingleCall< ::MurmurRPC::ACL_List, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ACLSet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ACLSet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ACLSet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ACLSet(rpc, service);
		auto fn = ::boost::bind(&V1_ACLSet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestACLSet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ACLGetEffectivePermissions : public RPCSingleSingleCall< ::MurmurRPC::ACL_Query, ::MurmurRPC::ACL > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ACLGetEffectivePermissions(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ACLGetEffectivePermissions::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ACLGetEffectivePermissions::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ACLGetEffectivePermissions(rpc, service);
		auto fn = ::boost::bind(&V1_ACLGetEffectivePermissions::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestACLGetEffectivePermissions(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ACLAddTemporaryGroup : public RPCSingleSingleCall< ::MurmurRPC::ACL_TemporaryGroup, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ACLAddTemporaryGroup(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ACLAddTemporaryGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ACLAddTemporaryGroup::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ACLAddTemporaryGroup(rpc, service);
		auto fn = ::boost::bind(&V1_ACLAddTemporaryGroup::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestACLAddTemporaryGroup(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ACLRemoveTemporaryGroup : public RPCSingleSingleCall< ::MurmurRPC::ACL_TemporaryGroup, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_ACLRemoveTemporaryGroup(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_ACLRemoveTemporaryGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ACLRemoveTemporaryGroup::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ACLRemoveTemporaryGroup(rpc, service);
		auto fn = ::boost::bind(&V1_ACLRemoveTemporaryGroup::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestACLRemoveTemporaryGroup(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_AuthenticatorStream : public RPCStreamStreamCall< ::MurmurRPC::Authenticator_Response, ::MurmurRPC::Authenticator_Request > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_AuthenticatorStream(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCStreamStreamCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	bool write() {
		bool processed = false;
		bool success;
		auto cb = [&success, &processed] (V1_AuthenticatorStream *, bool ok) {
			success = ok;
			processed = true;
		};
		stream.Write(response, callback(cb));
		while (!processed) {
			QCoreApplication::processEvents(QEventLoop::ExcludeSocketNotifiers, 100);
		}
		return success;
	}

	bool read() {
		bool processed = false;
		bool success;
		auto cb = [&success, &processed] (V1_AuthenticatorStream *, bool ok) {
			success = ok;
			processed = true;
		};
		stream.Read(&request, callback(cb));
		while (!processed) {
			QCoreApplication::processEvents(QEventLoop::ExcludeSocketNotifiers, 100);
		}
		return success;
	}

	bool writeRead() {
		return write() && read();
	}

	::boost::function<void(bool)> *callback(::boost::function<void(V1_AuthenticatorStream *, bool)> cb) {
		auto fn = ::boost::bind(&V1_AuthenticatorStream::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void handle(bool ok) {
		V1_AuthenticatorStream::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_AuthenticatorStream::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_AuthenticatorStream(rpc, service);
		auto fn = ::boost::bind(&V1_AuthenticatorStream::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestAuthenticatorStream(&call->context, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(V1_AuthenticatorStream *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};

class V1_DatabaseUserQuery : public RPCSingleSingleCall< ::MurmurRPC::DatabaseUser_Query, ::MurmurRPC::DatabaseUser_List > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_DatabaseUserQuery(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_DatabaseUserQuery::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_DatabaseUserQuery::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_DatabaseUserQuery(rpc, service);
		auto fn = ::boost::bind(&V1_DatabaseUserQuery::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestDatabaseUserQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_DatabaseUserGet : public RPCSingleSingleCall< ::MurmurRPC::DatabaseUser, ::MurmurRPC::DatabaseUser > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_DatabaseUserGet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_DatabaseUserGet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_DatabaseUserGet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_DatabaseUserGet(rpc, service);
		auto fn = ::boost::bind(&V1_DatabaseUserGet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestDatabaseUserGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_DatabaseUserUpdate : public RPCSingleSingleCall< ::MurmurRPC::DatabaseUser, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_DatabaseUserUpdate(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_DatabaseUserUpdate::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_DatabaseUserUpdate::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_DatabaseUserUpdate(rpc, service);
		auto fn = ::boost::bind(&V1_DatabaseUserUpdate::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestDatabaseUserUpdate(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_DatabaseUserRegister : public RPCSingleSingleCall< ::MurmurRPC::DatabaseUser, ::MurmurRPC::DatabaseUser > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_DatabaseUserRegister(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_DatabaseUserRegister::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_DatabaseUserRegister::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_DatabaseUserRegister(rpc, service);
		auto fn = ::boost::bind(&V1_DatabaseUserRegister::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestDatabaseUserRegister(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_DatabaseUserDeregister : public RPCSingleSingleCall< ::MurmurRPC::DatabaseUser, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_DatabaseUserDeregister(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_DatabaseUserDeregister::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_DatabaseUserDeregister::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_DatabaseUserDeregister(rpc, service);
		auto fn = ::boost::bind(&V1_DatabaseUserDeregister::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestDatabaseUserDeregister(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_DatabaseUserVerify : public RPCSingleSingleCall< ::MurmurRPC::DatabaseUser_Verify, ::MurmurRPC::DatabaseUser > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_DatabaseUserVerify(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_DatabaseUserVerify::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_DatabaseUserVerify::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_DatabaseUserVerify(rpc, service);
		auto fn = ::boost::bind(&V1_DatabaseUserVerify::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestDatabaseUserVerify(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_RedirectWhisperGroupAdd : public RPCSingleSingleCall< ::MurmurRPC::RedirectWhisperGroup, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_RedirectWhisperGroupAdd(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_RedirectWhisperGroupAdd::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_RedirectWhisperGroupAdd::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_RedirectWhisperGroupAdd(rpc, service);
		auto fn = ::boost::bind(&V1_RedirectWhisperGroupAdd::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRedirectWhisperGroupAdd(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_RedirectWhisperGroupRemove : public RPCSingleSingleCall< ::MurmurRPC::RedirectWhisperGroup, ::MurmurRPC::Void > {
public:
	::MurmurRPC::V1::AsyncService *service;

	V1_RedirectWhisperGroupRemove(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : RPCSingleSingleCall(rpc_impl), service(async_service) {
	}

	void impl(bool ok);

	void handle(bool ok) {
		V1_RedirectWhisperGroupRemove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_RedirectWhisperGroupRemove::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_RedirectWhisperGroupRemove(rpc, service);
		auto fn = ::boost::bind(&V1_RedirectWhisperGroupRemove::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRedirectWhisperGroupRemove(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void V1_Init(MurmurRPCImpl *impl, ::MurmurRPC::V1::AsyncService *service) {
	V1_GetUptime::create(impl, service);
	V1_GetVersion::create(impl, service);
	V1_Events::create(impl, service);
	V1_ServerCreate::create(impl, service);
	V1_ServerQuery::create(impl, service);
	V1_ServerGet::create(impl, service);
	V1_ServerStart::create(impl, service);
	V1_ServerStop::create(impl, service);
	V1_ServerRemove::create(impl, service);
	V1_ServerEvents::create(impl, service);
	V1_ContextActionAdd::create(impl, service);
	V1_ContextActionRemove::create(impl, service);
	V1_ContextActionEvents::create(impl, service);
	V1_TextMessageSend::create(impl, service);
	V1_TextMessageFilter::create(impl, service);
	V1_LogQuery::create(impl, service);
	V1_ConfigGet::create(impl, service);
	V1_ConfigGetField::create(impl, service);
	V1_ConfigSetField::create(impl, service);
	V1_ConfigGetDefault::create(impl, service);
	V1_ChannelQuery::create(impl, service);
	V1_ChannelGet::create(impl, service);
	V1_ChannelAdd::create(impl, service);
	V1_ChannelRemove::create(impl, service);
	V1_ChannelUpdate::create(impl, service);
	V1_UserQuery::create(impl, service);
	V1_UserGet::create(impl, service);
	V1_UserUpdate::create(impl, service);
	V1_UserKick::create(impl, service);
	V1_TreeQuery::create(impl, service);
	V1_BansGet::create(impl, service);
	V1_BansSet::create(impl, service);
	V1_ACLGet::create(impl, service);
	V1_ACLSet::create(impl, service);
	V1_ACLGetEffectivePermissions::create(impl, service);
	V1_ACLAddTemporaryGroup::create(impl, service);
	V1_ACLRemoveTemporaryGroup::create(impl, service);
	V1_AuthenticatorStream::create(impl, service);
	V1_DatabaseUserQuery::create(impl, service);
	V1_DatabaseUserGet::create(impl, service);
	V1_DatabaseUserUpdate::create(impl, service);
	V1_DatabaseUserRegister::create(impl, service);
	V1_DatabaseUserDeregister::create(impl, service);
	V1_DatabaseUserVerify::create(impl, service);
	V1_RedirectWhisperGroupAdd::create(impl, service);
	V1_RedirectWhisperGroupRemove::create(impl, service);
}

}
}
