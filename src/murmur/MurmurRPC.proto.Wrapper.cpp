// DO NOT EDIT!
// Auto generated by scripts/protoc-gen-grpcwrapper

namespace MurmurRPC {
namespace Wrapper {

class ServerService_Create : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Server > response;

	ServerService_Create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ServerService_Create::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ServerService_Create::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Create::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Create(rpc, service);
		auto fn = ::boost::bind(&ServerService_Create::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestCreate(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ServerService_Query : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Server_List > response;

	ServerService_Query(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ServerService_Query::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ServerService_Query::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Query::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Query(rpc, service);
		auto fn = ::boost::bind(&ServerService_Query::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQuery(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ServerService_Get : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Server > response;

	ServerService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ServerService_Get::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ServerService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Get::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Get(rpc, service);
		auto fn = ::boost::bind(&ServerService_Get::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGet(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ServerService_Start : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ServerService_Start(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ServerService_Start::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ServerService_Start::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Start::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Start(rpc, service);
		auto fn = ::boost::bind(&ServerService_Start::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestStart(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ServerService_Stop : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ServerService_Stop(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ServerService_Stop::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ServerService_Stop::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Stop::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Stop(rpc, service);
		auto fn = ::boost::bind(&ServerService_Stop::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestStop(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ServerService_Remove : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ServerService_Remove(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ServerService_Remove::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ServerService_Remove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Remove::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Remove(rpc, service);
		auto fn = ::boost::bind(&ServerService_Remove::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRemove(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ServerService_Events : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncWriter < ::MurmurRPC::Server_Event > response;

	ServerService_Events(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ServerService_Events::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	::boost::function<void(bool)> *callback(::boost::function<void(ServerService_Events *, bool)> cb) {
		auto fn = ::boost::bind(&ServerService_Events::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void error(::grpc::Status &err) {
		response.Finish(err, this->done());
	}

	void handle(bool ok) {
		ServerService_Events::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Events::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Events(rpc, service);
		auto fn = ::boost::bind(&ServerService_Events::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestEvents(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(ServerService_Events *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};
void ServerService_Init(MurmurRPCImpl *impl, ::MurmurRPC::ServerService::AsyncService *service) {
	ServerService_Create::create(impl, service);
	ServerService_Query::create(impl, service);
	ServerService_Get::create(impl, service);
	ServerService_Start::create(impl, service);
	ServerService_Stop::create(impl, service);
	ServerService_Remove::create(impl, service);
	ServerService_Events::create(impl, service);
}

class MetaService_GetUptime : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::MetaService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Uptime > response;

	MetaService_GetUptime(MurmurRPCImpl *rpc, ::MurmurRPC::MetaService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&MetaService_GetUptime::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		MetaService_GetUptime::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&MetaService_GetUptime::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::MetaService::AsyncService *service) {
		auto call = new MetaService_GetUptime(rpc, service);
		auto fn = ::boost::bind(&MetaService_GetUptime::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetUptime(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class MetaService_GetVersion : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::MetaService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Version > response;

	MetaService_GetVersion(MurmurRPCImpl *rpc, ::MurmurRPC::MetaService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&MetaService_GetVersion::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		MetaService_GetVersion::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&MetaService_GetVersion::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::MetaService::AsyncService *service) {
		auto call = new MetaService_GetVersion(rpc, service);
		auto fn = ::boost::bind(&MetaService_GetVersion::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetVersion(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class MetaService_Events : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::MetaService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncWriter < ::MurmurRPC::Event > response;

	MetaService_Events(MurmurRPCImpl *rpc, ::MurmurRPC::MetaService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&MetaService_Events::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	::boost::function<void(bool)> *callback(::boost::function<void(MetaService_Events *, bool)> cb) {
		auto fn = ::boost::bind(&MetaService_Events::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void error(::grpc::Status &err) {
		response.Finish(err, this->done());
	}

	void handle(bool ok) {
		MetaService_Events::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&MetaService_Events::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::MetaService::AsyncService *service) {
		auto call = new MetaService_Events(rpc, service);
		auto fn = ::boost::bind(&MetaService_Events::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestEvents(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(MetaService_Events *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};
void MetaService_Init(MurmurRPCImpl *impl, ::MurmurRPC::MetaService::AsyncService *service) {
	MetaService_GetUptime::create(impl, service);
	MetaService_GetVersion::create(impl, service);
	MetaService_Events::create(impl, service);
}

class ContextActionService_Add : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ContextActionService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ContextAction request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ContextActionService_Add(MurmurRPCImpl *rpc, ::MurmurRPC::ContextActionService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ContextActionService_Add::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ContextActionService_Add::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ContextActionService_Add::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ContextActionService::AsyncService *service) {
		auto call = new ContextActionService_Add(rpc, service);
		auto fn = ::boost::bind(&ContextActionService_Add::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestAdd(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ContextActionService_Remove : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ContextActionService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ContextAction request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ContextActionService_Remove(MurmurRPCImpl *rpc, ::MurmurRPC::ContextActionService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ContextActionService_Remove::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ContextActionService_Remove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ContextActionService_Remove::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ContextActionService::AsyncService *service) {
		auto call = new ContextActionService_Remove(rpc, service);
		auto fn = ::boost::bind(&ContextActionService_Remove::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRemove(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ContextActionService_Events : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ContextActionService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ContextAction request;
	::grpc::ServerAsyncWriter < ::MurmurRPC::ContextAction > response;

	ContextActionService_Events(MurmurRPCImpl *rpc, ::MurmurRPC::ContextActionService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ContextActionService_Events::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	::boost::function<void(bool)> *callback(::boost::function<void(ContextActionService_Events *, bool)> cb) {
		auto fn = ::boost::bind(&ContextActionService_Events::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void error(::grpc::Status &err) {
		response.Finish(err, this->done());
	}

	void handle(bool ok) {
		ContextActionService_Events::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ContextActionService_Events::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ContextActionService::AsyncService *service) {
		auto call = new ContextActionService_Events(rpc, service);
		auto fn = ::boost::bind(&ContextActionService_Events::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestEvents(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(ContextActionService_Events *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};
void ContextActionService_Init(MurmurRPCImpl *impl, ::MurmurRPC::ContextActionService::AsyncService *service) {
	ContextActionService_Add::create(impl, service);
	ContextActionService_Remove::create(impl, service);
	ContextActionService_Events::create(impl, service);
}

class TextMessageService_Send : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::TextMessageService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::TextMessage request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	TextMessageService_Send(MurmurRPCImpl *rpc, ::MurmurRPC::TextMessageService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&TextMessageService_Send::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		TextMessageService_Send::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&TextMessageService_Send::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::TextMessageService::AsyncService *service) {
		auto call = new TextMessageService_Send(rpc, service);
		auto fn = ::boost::bind(&TextMessageService_Send::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestSend(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void TextMessageService_Init(MurmurRPCImpl *impl, ::MurmurRPC::TextMessageService::AsyncService *service) {
	TextMessageService_Send::create(impl, service);
}
void LogService_Init(MurmurRPCImpl *impl, ::MurmurRPC::LogService::AsyncService *service) {
}

class ConfigService_GetDefault : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ConfigService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Config > response;

	ConfigService_GetDefault(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ConfigService_GetDefault::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ConfigService_GetDefault::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ConfigService_GetDefault::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) {
		auto call = new ConfigService_GetDefault(rpc, service);
		auto fn = ::boost::bind(&ConfigService_GetDefault::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetDefault(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ConfigService_SetDefault : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ConfigService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Config request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ConfigService_SetDefault(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ConfigService_SetDefault::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ConfigService_SetDefault::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ConfigService_SetDefault::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) {
		auto call = new ConfigService_SetDefault(rpc, service);
		auto fn = ::boost::bind(&ConfigService_SetDefault::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestSetDefault(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ConfigService_Query : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ConfigService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Config_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Config > response;

	ConfigService_Query(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ConfigService_Query::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ConfigService_Query::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ConfigService_Query::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) {
		auto call = new ConfigService_Query(rpc, service);
		auto fn = ::boost::bind(&ConfigService_Query::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQuery(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void ConfigService_Init(MurmurRPCImpl *impl, ::MurmurRPC::ConfigService::AsyncService *service) {
	ConfigService_GetDefault::create(impl, service);
	ConfigService_SetDefault::create(impl, service);
	ConfigService_Query::create(impl, service);
}

class ChannelService_Query : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ChannelService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel_List > response;

	ChannelService_Query(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ChannelService_Query::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ChannelService_Query::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ChannelService_Query::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) {
		auto call = new ChannelService_Query(rpc, service);
		auto fn = ::boost::bind(&ChannelService_Query::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQuery(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ChannelService_Get : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ChannelService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel > response;

	ChannelService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ChannelService_Get::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ChannelService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ChannelService_Get::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) {
		auto call = new ChannelService_Get(rpc, service);
		auto fn = ::boost::bind(&ChannelService_Get::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGet(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ChannelService_Add : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ChannelService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel > response;

	ChannelService_Add(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ChannelService_Add::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ChannelService_Add::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ChannelService_Add::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) {
		auto call = new ChannelService_Add(rpc, service);
		auto fn = ::boost::bind(&ChannelService_Add::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestAdd(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ChannelService_Remove : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ChannelService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ChannelService_Remove(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ChannelService_Remove::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ChannelService_Remove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ChannelService_Remove::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) {
		auto call = new ChannelService_Remove(rpc, service);
		auto fn = ::boost::bind(&ChannelService_Remove::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRemove(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ChannelService_Update : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ChannelService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel > response;

	ChannelService_Update(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ChannelService_Update::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ChannelService_Update::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ChannelService_Update::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) {
		auto call = new ChannelService_Update(rpc, service);
		auto fn = ::boost::bind(&ChannelService_Update::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUpdate(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void ChannelService_Init(MurmurRPCImpl *impl, ::MurmurRPC::ChannelService::AsyncService *service) {
	ChannelService_Query::create(impl, service);
	ChannelService_Get::create(impl, service);
	ChannelService_Add::create(impl, service);
	ChannelService_Remove::create(impl, service);
	ChannelService_Update::create(impl, service);
}

class UserService_Query : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::UserService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::User_List > response;

	UserService_Query(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&UserService_Query::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		UserService_Query::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&UserService_Query::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) {
		auto call = new UserService_Query(rpc, service);
		auto fn = ::boost::bind(&UserService_Query::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQuery(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class UserService_Get : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::UserService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::User > response;

	UserService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&UserService_Get::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		UserService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&UserService_Get::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) {
		auto call = new UserService_Get(rpc, service);
		auto fn = ::boost::bind(&UserService_Get::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGet(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class UserService_Update : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::UserService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::User > response;

	UserService_Update(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&UserService_Update::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		UserService_Update::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&UserService_Update::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) {
		auto call = new UserService_Update(rpc, service);
		auto fn = ::boost::bind(&UserService_Update::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUpdate(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class UserService_Kick : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::UserService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User_Kick request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	UserService_Kick(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&UserService_Kick::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		UserService_Kick::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&UserService_Kick::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) {
		auto call = new UserService_Kick(rpc, service);
		auto fn = ::boost::bind(&UserService_Kick::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestKick(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void UserService_Init(MurmurRPCImpl *impl, ::MurmurRPC::UserService::AsyncService *service) {
	UserService_Query::create(impl, service);
	UserService_Get::create(impl, service);
	UserService_Update::create(impl, service);
	UserService_Kick::create(impl, service);
}

class TreeService_Get : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::TreeService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Tree > response;

	TreeService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::TreeService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&TreeService_Get::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		TreeService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&TreeService_Get::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::TreeService::AsyncService *service) {
		auto call = new TreeService_Get(rpc, service);
		auto fn = ::boost::bind(&TreeService_Get::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGet(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void TreeService_Init(MurmurRPCImpl *impl, ::MurmurRPC::TreeService::AsyncService *service) {
	TreeService_Get::create(impl, service);
}

class BanService_Get : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::BanService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Ban_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Ban_List > response;

	BanService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::BanService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&BanService_Get::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		BanService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&BanService_Get::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::BanService::AsyncService *service) {
		auto call = new BanService_Get(rpc, service);
		auto fn = ::boost::bind(&BanService_Get::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGet(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class BanService_Set : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::BanService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Ban_List request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	BanService_Set(MurmurRPCImpl *rpc, ::MurmurRPC::BanService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&BanService_Set::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		BanService_Set::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&BanService_Set::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::BanService::AsyncService *service) {
		auto call = new BanService_Set(rpc, service);
		auto fn = ::boost::bind(&BanService_Set::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestSet(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void BanService_Init(MurmurRPCImpl *impl, ::MurmurRPC::BanService::AsyncService *service) {
	BanService_Get::create(impl, service);
	BanService_Set::create(impl, service);
}

class ACLService_Get : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ACLService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::ACL_List > response;

	ACLService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ACLService_Get::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ACLService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ACLService_Get::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) {
		auto call = new ACLService_Get(rpc, service);
		auto fn = ::boost::bind(&ACLService_Get::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGet(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ACLService_Set : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ACLService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_List request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ACLService_Set(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ACLService_Set::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ACLService_Set::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ACLService_Set::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) {
		auto call = new ACLService_Set(rpc, service);
		auto fn = ::boost::bind(&ACLService_Set::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestSet(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ACLService_GetEffectivePermissions : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ACLService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::ACL > response;

	ACLService_GetEffectivePermissions(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ACLService_GetEffectivePermissions::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ACLService_GetEffectivePermissions::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ACLService_GetEffectivePermissions::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) {
		auto call = new ACLService_GetEffectivePermissions(rpc, service);
		auto fn = ::boost::bind(&ACLService_GetEffectivePermissions::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetEffectivePermissions(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ACLService_AddTemporaryGroup : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ACLService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_TemporaryGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ACLService_AddTemporaryGroup(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ACLService_AddTemporaryGroup::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ACLService_AddTemporaryGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ACLService_AddTemporaryGroup::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) {
		auto call = new ACLService_AddTemporaryGroup(rpc, service);
		auto fn = ::boost::bind(&ACLService_AddTemporaryGroup::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestAddTemporaryGroup(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ACLService_RemoveTemporaryGroup : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ACLService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_TemporaryGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ACLService_RemoveTemporaryGroup(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ACLService_RemoveTemporaryGroup::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ACLService_RemoveTemporaryGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ACLService_RemoveTemporaryGroup::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) {
		auto call = new ACLService_RemoveTemporaryGroup(rpc, service);
		auto fn = ::boost::bind(&ACLService_RemoveTemporaryGroup::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRemoveTemporaryGroup(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void ACLService_Init(MurmurRPCImpl *impl, ::MurmurRPC::ACLService::AsyncService *service) {
	ACLService_Get::create(impl, service);
	ACLService_Set::create(impl, service);
	ACLService_GetEffectivePermissions::create(impl, service);
	ACLService_AddTemporaryGroup::create(impl, service);
	ACLService_RemoveTemporaryGroup::create(impl, service);
}

class AuthenticatorService_Stream : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::AuthenticatorService::AsyncService *service;

	::grpc::ServerContext context;
	::grpc::ServerAsyncReaderWriter< ::MurmurRPC::Authenticator_Message, ::MurmurRPC::Authenticator_Message > stream;

	AuthenticatorService_Stream(MurmurRPCImpl *rpc, ::MurmurRPC::AuthenticatorService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&AuthenticatorService_Stream::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		stream.Finish(err, this->done());
	}

	void handle(bool ok) {
		AuthenticatorService_Stream::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&AuthenticatorService_Stream::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::AuthenticatorService::AsyncService *service) {
		auto call = new AuthenticatorService_Stream(rpc, service);
		auto fn = ::boost::bind(&AuthenticatorService_Stream::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestStream(&call->context, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class AuthenticatorService_RegistrationStream : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::AuthenticatorService::AsyncService *service;

	::grpc::ServerContext context;
	::grpc::ServerAsyncReaderWriter< ::MurmurRPC::Authenticator_Message, ::MurmurRPC::Authenticator_Message > stream;

	AuthenticatorService_RegistrationStream(MurmurRPCImpl *rpc, ::MurmurRPC::AuthenticatorService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&AuthenticatorService_RegistrationStream::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		stream.Finish(err, this->done());
	}

	void handle(bool ok) {
		AuthenticatorService_RegistrationStream::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&AuthenticatorService_RegistrationStream::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::AuthenticatorService::AsyncService *service) {
		auto call = new AuthenticatorService_RegistrationStream(rpc, service);
		auto fn = ::boost::bind(&AuthenticatorService_RegistrationStream::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRegistrationStream(&call->context, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void AuthenticatorService_Init(MurmurRPCImpl *impl, ::MurmurRPC::AuthenticatorService::AsyncService *service) {
	AuthenticatorService_Stream::create(impl, service);
	AuthenticatorService_RegistrationStream::create(impl, service);
}

class DatabaseService_Query : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser_List > response;

	DatabaseService_Query(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Query::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		DatabaseService_Query::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Query::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Query(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Query::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQuery(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class DatabaseService_Get : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser > response;

	DatabaseService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Get::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		DatabaseService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Get::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Get(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Get::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGet(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class DatabaseService_Update : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	DatabaseService_Update(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Update::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		DatabaseService_Update::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Update::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Update(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Update::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUpdate(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class DatabaseService_Register : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser > response;

	DatabaseService_Register(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Register::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		DatabaseService_Register::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Register::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Register(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Register::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRegister(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class DatabaseService_Deregister : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	DatabaseService_Deregister(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Deregister::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		DatabaseService_Deregister::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Deregister::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Deregister(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Deregister::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestDeregister(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class DatabaseService_Verify : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser_Verify request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser > response;

	DatabaseService_Verify(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Verify::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		DatabaseService_Verify::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Verify::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Verify(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Verify::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestVerify(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void DatabaseService_Init(MurmurRPCImpl *impl, ::MurmurRPC::DatabaseService::AsyncService *service) {
	DatabaseService_Query::create(impl, service);
	DatabaseService_Get::create(impl, service);
	DatabaseService_Update::create(impl, service);
	DatabaseService_Register::create(impl, service);
	DatabaseService_Deregister::create(impl, service);
	DatabaseService_Verify::create(impl, service);
}

class AudioService_SetRedirectWhisperGroup : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::AudioService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::RedirectWhisperGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	AudioService_SetRedirectWhisperGroup(MurmurRPCImpl *rpc, ::MurmurRPC::AudioService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&AudioService_SetRedirectWhisperGroup::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(::grpc::Status &err) {
		response.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		AudioService_SetRedirectWhisperGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&AudioService_SetRedirectWhisperGroup::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::AudioService::AsyncService *service) {
		auto call = new AudioService_SetRedirectWhisperGroup(rpc, service);
		auto fn = ::boost::bind(&AudioService_SetRedirectWhisperGroup::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestSetRedirectWhisperGroup(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void AudioService_Init(MurmurRPCImpl *impl, ::MurmurRPC::AudioService::AsyncService *service) {
	AudioService_SetRedirectWhisperGroup::create(impl, service);
}

}
}
