// DO NOT EDIT!
// Auto generated by scripts/protoc-gen-grpcwrapper

namespace MurmurRPC {
namespace Wrapper {


struct ServerService_Create : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Server > response;

	ServerService_Create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ServerService_Create::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Server >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ServerService_Create::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Create::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Create(rpc, service);
		auto fn = ::boost::bind(&ServerService_Create::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestCreate(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct ServerService_Query : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Server_List > response;

	ServerService_Query(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ServerService_Query::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Server_List >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ServerService_Query::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Query::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Query(rpc, service);
		auto fn = ::boost::bind(&ServerService_Query::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestQuery(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct ServerService_Get : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Server > response;

	ServerService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ServerService_Get::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Server >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ServerService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Get::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Get(rpc, service);
		auto fn = ::boost::bind(&ServerService_Get::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestGet(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct ServerService_Start : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ServerService_Start(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ServerService_Start::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ServerService_Start::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Start::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Start(rpc, service);
		auto fn = ::boost::bind(&ServerService_Start::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestStart(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct ServerService_Stop : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ServerService_Stop(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ServerService_Stop::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ServerService_Stop::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Stop::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Stop(rpc, service);
		auto fn = ::boost::bind(&ServerService_Stop::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestStop(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct ServerService_Remove : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ServerService_Remove(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ServerService_Remove::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ServerService_Remove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Remove::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Remove(rpc, service);
		auto fn = ::boost::bind(&ServerService_Remove::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestRemove(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

void ServerService_Init(MurmurRPCImpl *impl, ::MurmurRPC::ServerService::AsyncService *service) {
	ServerService_Create::create(impl, service);
	ServerService_Query::create(impl, service);
	ServerService_Get::create(impl, service);
	ServerService_Start::create(impl, service);
	ServerService_Stop::create(impl, service);
	ServerService_Remove::create(impl, service);
}


struct MetaService_GetUptime : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::MetaService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Uptime > response;

	MetaService_GetUptime(MurmurRPCImpl *rpc, ::MurmurRPC::MetaService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&MetaService_GetUptime::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Uptime >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		MetaService_GetUptime::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&MetaService_GetUptime::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::MetaService::AsyncService *service) {
		auto call = new MetaService_GetUptime(rpc, service);
		auto fn = ::boost::bind(&MetaService_GetUptime::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestGetUptime(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct MetaService_GetVersion : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::MetaService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Version > response;

	MetaService_GetVersion(MurmurRPCImpl *rpc, ::MurmurRPC::MetaService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&MetaService_GetVersion::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Version >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		MetaService_GetVersion::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&MetaService_GetVersion::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::MetaService::AsyncService *service) {
		auto call = new MetaService_GetVersion(rpc, service);
		auto fn = ::boost::bind(&MetaService_GetVersion::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestGetVersion(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

void MetaService_Init(MurmurRPCImpl *impl, ::MurmurRPC::MetaService::AsyncService *service) {
	MetaService_GetUptime::create(impl, service);
	MetaService_GetVersion::create(impl, service);
}


struct ContextActionService_Add : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ContextActionService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ContextAction request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ContextActionService_Add(MurmurRPCImpl *rpc, ::MurmurRPC::ContextActionService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ContextActionService_Add::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ContextActionService_Add::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ContextActionService_Add::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ContextActionService::AsyncService *service) {
		auto call = new ContextActionService_Add(rpc, service);
		auto fn = ::boost::bind(&ContextActionService_Add::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestAdd(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct ContextActionService_Remove : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ContextActionService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ContextAction request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ContextActionService_Remove(MurmurRPCImpl *rpc, ::MurmurRPC::ContextActionService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ContextActionService_Remove::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ContextActionService_Remove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ContextActionService_Remove::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ContextActionService::AsyncService *service) {
		auto call = new ContextActionService_Remove(rpc, service);
		auto fn = ::boost::bind(&ContextActionService_Remove::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestRemove(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

void ContextActionService_Init(MurmurRPCImpl *impl, ::MurmurRPC::ContextActionService::AsyncService *service) {
	ContextActionService_Add::create(impl, service);
	ContextActionService_Remove::create(impl, service);
}


struct TextMessageService_Send : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::TextMessageService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::TextMessage request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	TextMessageService_Send(MurmurRPCImpl *rpc, ::MurmurRPC::TextMessageService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&TextMessageService_Send::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		TextMessageService_Send::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&TextMessageService_Send::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::TextMessageService::AsyncService *service) {
		auto call = new TextMessageService_Send(rpc, service);
		auto fn = ::boost::bind(&TextMessageService_Send::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestSend(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

void TextMessageService_Init(MurmurRPCImpl *impl, ::MurmurRPC::TextMessageService::AsyncService *service) {
	TextMessageService_Send::create(impl, service);
}
void LogService_Init(MurmurRPCImpl *impl, ::MurmurRPC::LogService::AsyncService *service) {
}


struct ConfigService_GetDefault : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ConfigService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Config > response;

	ConfigService_GetDefault(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ConfigService_GetDefault::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Config >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ConfigService_GetDefault::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ConfigService_GetDefault::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) {
		auto call = new ConfigService_GetDefault(rpc, service);
		auto fn = ::boost::bind(&ConfigService_GetDefault::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestGetDefault(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct ConfigService_SetDefault : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ConfigService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Config request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ConfigService_SetDefault(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ConfigService_SetDefault::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ConfigService_SetDefault::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ConfigService_SetDefault::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) {
		auto call = new ConfigService_SetDefault(rpc, service);
		auto fn = ::boost::bind(&ConfigService_SetDefault::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestSetDefault(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct ConfigService_Query : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ConfigService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Config_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Config > response;

	ConfigService_Query(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ConfigService_Query::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Config >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ConfigService_Query::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ConfigService_Query::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) {
		auto call = new ConfigService_Query(rpc, service);
		auto fn = ::boost::bind(&ConfigService_Query::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestQuery(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

void ConfigService_Init(MurmurRPCImpl *impl, ::MurmurRPC::ConfigService::AsyncService *service) {
	ConfigService_GetDefault::create(impl, service);
	ConfigService_SetDefault::create(impl, service);
	ConfigService_Query::create(impl, service);
}


struct ChannelService_Query : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ChannelService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel_List > response;

	ChannelService_Query(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ChannelService_Query::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Channel_List >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ChannelService_Query::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ChannelService_Query::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) {
		auto call = new ChannelService_Query(rpc, service);
		auto fn = ::boost::bind(&ChannelService_Query::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestQuery(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct ChannelService_Get : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ChannelService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel > response;

	ChannelService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ChannelService_Get::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Channel >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ChannelService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ChannelService_Get::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) {
		auto call = new ChannelService_Get(rpc, service);
		auto fn = ::boost::bind(&ChannelService_Get::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestGet(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct ChannelService_Add : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ChannelService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel > response;

	ChannelService_Add(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ChannelService_Add::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Channel >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ChannelService_Add::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ChannelService_Add::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) {
		auto call = new ChannelService_Add(rpc, service);
		auto fn = ::boost::bind(&ChannelService_Add::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestAdd(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct ChannelService_Remove : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ChannelService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ChannelService_Remove(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ChannelService_Remove::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ChannelService_Remove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ChannelService_Remove::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) {
		auto call = new ChannelService_Remove(rpc, service);
		auto fn = ::boost::bind(&ChannelService_Remove::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestRemove(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct ChannelService_Update : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ChannelService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel > response;

	ChannelService_Update(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ChannelService_Update::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Channel >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ChannelService_Update::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ChannelService_Update::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) {
		auto call = new ChannelService_Update(rpc, service);
		auto fn = ::boost::bind(&ChannelService_Update::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestUpdate(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

void ChannelService_Init(MurmurRPCImpl *impl, ::MurmurRPC::ChannelService::AsyncService *service) {
	ChannelService_Query::create(impl, service);
	ChannelService_Get::create(impl, service);
	ChannelService_Add::create(impl, service);
	ChannelService_Remove::create(impl, service);
	ChannelService_Update::create(impl, service);
}


struct UserService_Query : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::UserService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::User_List > response;

	UserService_Query(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&UserService_Query::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::User_List >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		UserService_Query::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&UserService_Query::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) {
		auto call = new UserService_Query(rpc, service);
		auto fn = ::boost::bind(&UserService_Query::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestQuery(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct UserService_Get : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::UserService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::User > response;

	UserService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&UserService_Get::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::User >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		UserService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&UserService_Get::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) {
		auto call = new UserService_Get(rpc, service);
		auto fn = ::boost::bind(&UserService_Get::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestGet(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct UserService_Update : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::UserService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::User > response;

	UserService_Update(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&UserService_Update::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::User >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		UserService_Update::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&UserService_Update::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) {
		auto call = new UserService_Update(rpc, service);
		auto fn = ::boost::bind(&UserService_Update::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestUpdate(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct UserService_Kick : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::UserService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User_Kick request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	UserService_Kick(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&UserService_Kick::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		UserService_Kick::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&UserService_Kick::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) {
		auto call = new UserService_Kick(rpc, service);
		auto fn = ::boost::bind(&UserService_Kick::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestKick(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

void UserService_Init(MurmurRPCImpl *impl, ::MurmurRPC::UserService::AsyncService *service) {
	UserService_Query::create(impl, service);
	UserService_Get::create(impl, service);
	UserService_Update::create(impl, service);
	UserService_Kick::create(impl, service);
}


struct TreeService_Get : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::TreeService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Tree > response;

	TreeService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::TreeService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&TreeService_Get::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Tree >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		TreeService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&TreeService_Get::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::TreeService::AsyncService *service) {
		auto call = new TreeService_Get(rpc, service);
		auto fn = ::boost::bind(&TreeService_Get::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestGet(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

void TreeService_Init(MurmurRPCImpl *impl, ::MurmurRPC::TreeService::AsyncService *service) {
	TreeService_Get::create(impl, service);
}
void BanService_Init(MurmurRPCImpl *impl, ::MurmurRPC::BanService::AsyncService *service) {
}


struct ACLService_Get : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ACLService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::ACL_List > response;

	ACLService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ACLService_Get::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::ACL_List >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ACLService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ACLService_Get::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) {
		auto call = new ACLService_Get(rpc, service);
		auto fn = ::boost::bind(&ACLService_Get::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestGet(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct ACLService_Set : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ACLService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_List request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ACLService_Set(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ACLService_Set::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ACLService_Set::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ACLService_Set::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) {
		auto call = new ACLService_Set(rpc, service);
		auto fn = ::boost::bind(&ACLService_Set::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestSet(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct ACLService_GetEffectivePermissions : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ACLService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::ACL > response;

	ACLService_GetEffectivePermissions(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ACLService_GetEffectivePermissions::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::ACL >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ACLService_GetEffectivePermissions::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ACLService_GetEffectivePermissions::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) {
		auto call = new ACLService_GetEffectivePermissions(rpc, service);
		auto fn = ::boost::bind(&ACLService_GetEffectivePermissions::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestGetEffectivePermissions(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct ACLService_AddTemporaryGroup : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ACLService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_TemporaryGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ACLService_AddTemporaryGroup(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ACLService_AddTemporaryGroup::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ACLService_AddTemporaryGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ACLService_AddTemporaryGroup::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) {
		auto call = new ACLService_AddTemporaryGroup(rpc, service);
		auto fn = ::boost::bind(&ACLService_AddTemporaryGroup::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestAddTemporaryGroup(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct ACLService_RemoveTemporaryGroup : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::ACLService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_TemporaryGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	ACLService_RemoveTemporaryGroup(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&ACLService_RemoveTemporaryGroup::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		ACLService_RemoveTemporaryGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ACLService_RemoveTemporaryGroup::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) {
		auto call = new ACLService_RemoveTemporaryGroup(rpc, service);
		auto fn = ::boost::bind(&ACLService_RemoveTemporaryGroup::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestRemoveTemporaryGroup(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

void ACLService_Init(MurmurRPCImpl *impl, ::MurmurRPC::ACLService::AsyncService *service) {
	ACLService_Get::create(impl, service);
	ACLService_Set::create(impl, service);
	ACLService_GetEffectivePermissions::create(impl, service);
	ACLService_AddTemporaryGroup::create(impl, service);
	ACLService_RemoveTemporaryGroup::create(impl, service);
}
void AuthenticatorService_Init(MurmurRPCImpl *impl, ::MurmurRPC::AuthenticatorService::AsyncService *service) {
}


struct DatabaseService_Query : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser_List > response;

	DatabaseService_Query(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Query::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::DatabaseUser_List >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		DatabaseService_Query::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Query::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Query(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Query::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestQuery(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct DatabaseService_Get : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser > response;

	DatabaseService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Get::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::DatabaseUser >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		DatabaseService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Get::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Get(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Get::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestGet(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct DatabaseService_Update : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	DatabaseService_Update(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Update::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		DatabaseService_Update::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Update::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Update(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Update::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestUpdate(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct DatabaseService_Register : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser > response;

	DatabaseService_Register(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Register::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::DatabaseUser >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		DatabaseService_Register::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Register::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Register(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Register::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestRegister(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct DatabaseService_Deregister : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	DatabaseService_Deregister(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Deregister::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		DatabaseService_Deregister::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Deregister::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Deregister(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Deregister::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestDeregister(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};



struct DatabaseService_Verify : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser_Verify request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser > response;

	DatabaseService_Verify(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Verify::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::DatabaseUser >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		DatabaseService_Verify::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Verify::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Verify(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Verify::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestVerify(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

void DatabaseService_Init(MurmurRPCImpl *impl, ::MurmurRPC::DatabaseService::AsyncService *service) {
	DatabaseService_Query::create(impl, service);
	DatabaseService_Get::create(impl, service);
	DatabaseService_Update::create(impl, service);
	DatabaseService_Register::create(impl, service);
	DatabaseService_Deregister::create(impl, service);
	DatabaseService_Verify::create(impl, service);
}


struct AudioService_SetRedirectWhisperGroup : public RPCCall {
	MurmurRPCImpl *rpc;
	::MurmurRPC::AudioService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::RedirectWhisperGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > response;

	AudioService_SetRedirectWhisperGroup(MurmurRPCImpl *rpc, ::MurmurRPC::AudioService::AsyncService *service) : rpc(rpc), service(service), response(&context) {
	}

	void impl();

	void finish() {
		delete this;
	}

	::boost::function<void()> *done() {
		auto done_fn = ::boost::bind(&AudioService_SetRedirectWhisperGroup::finish, this);
		return new ::boost::function<void()>(done_fn);
	}

	::boost::function<void(::grpc::Status&)> *error() {
		auto error_fn = ::boost::bind(&::grpc::ServerAsyncResponseWriter< ::MurmurRPC::Void >::FinishWithError, &this->response, _1, this->done());
		return new ::boost::function<void(::grpc::Status&)>(error_fn);
	}

	void handle() {
		AudioService_SetRedirectWhisperGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&AudioService_SetRedirectWhisperGroup::impl, this), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::AudioService::AsyncService *service) {
		auto call = new AudioService_SetRedirectWhisperGroup(rpc, service);
		auto fn = ::boost::bind(&AudioService_SetRedirectWhisperGroup::handle, call);
		auto fn_ptr = new ::boost::function<void()>(fn);
		service->RequestSetRedirectWhisperGroup(&call->context, &call->request, &call->response, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

void AudioService_Init(MurmurRPCImpl *impl, ::MurmurRPC::AudioService::AsyncService *service) {
	AudioService_SetRedirectWhisperGroup::create(impl, service);
}

}
}
