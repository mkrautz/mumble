// DO NOT EDIT!
// Auto generated by scripts/protoc-gen-grpcwrapper

namespace MurmurRPC {
namespace Wrapper {

class V1_GetUptime : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Uptime > stream;

	V1_GetUptime(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_GetUptime::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_GetUptime::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_GetUptime::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_GetUptime(rpc, service);
		auto fn = ::boost::bind(&V1_GetUptime::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetUptime(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_GetVersion : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Version > stream;

	V1_GetVersion(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_GetVersion::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_GetVersion::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_GetVersion::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_GetVersion(rpc, service);
		auto fn = ::boost::bind(&V1_GetVersion::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetVersion(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_Events : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncWriter < ::MurmurRPC::Event > stream;

	V1_Events(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_Events::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	::boost::function<void(bool)> *callback(::boost::function<void(V1_Events *, bool)> cb) {
		auto fn = ::boost::bind(&V1_Events::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void error(const ::grpc::Status &err) {
		stream.Finish(err, this->done());
	}

	void handle(bool ok) {
		V1_Events::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_Events::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_Events(rpc, service);
		auto fn = ::boost::bind(&V1_Events::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestEvents(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(V1_Events *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};

class V1_ServerCreate : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Server > stream;

	V1_ServerCreate(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ServerCreate::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ServerCreate::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ServerCreate::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ServerCreate(rpc, service);
		auto fn = ::boost::bind(&V1_ServerCreate::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestServerCreate(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ServerQuery : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Server_List > stream;

	V1_ServerQuery(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ServerQuery::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ServerQuery::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ServerQuery::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ServerQuery(rpc, service);
		auto fn = ::boost::bind(&V1_ServerQuery::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestServerQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ServerGet : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Server > stream;

	V1_ServerGet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ServerGet::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ServerGet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ServerGet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ServerGet(rpc, service);
		auto fn = ::boost::bind(&V1_ServerGet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestServerGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ServerStart : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_ServerStart(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ServerStart::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ServerStart::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ServerStart::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ServerStart(rpc, service);
		auto fn = ::boost::bind(&V1_ServerStart::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestServerStart(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ServerStop : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_ServerStop(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ServerStop::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ServerStop::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ServerStop::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ServerStop(rpc, service);
		auto fn = ::boost::bind(&V1_ServerStop::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestServerStop(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ServerRemove : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_ServerRemove(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ServerRemove::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ServerRemove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ServerRemove::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ServerRemove(rpc, service);
		auto fn = ::boost::bind(&V1_ServerRemove::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestServerRemove(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ServerEvents : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncWriter < ::MurmurRPC::Server_Event > stream;

	V1_ServerEvents(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ServerEvents::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	::boost::function<void(bool)> *callback(::boost::function<void(V1_ServerEvents *, bool)> cb) {
		auto fn = ::boost::bind(&V1_ServerEvents::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void error(const ::grpc::Status &err) {
		stream.Finish(err, this->done());
	}

	void handle(bool ok) {
		V1_ServerEvents::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ServerEvents::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ServerEvents(rpc, service);
		auto fn = ::boost::bind(&V1_ServerEvents::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestServerEvents(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(V1_ServerEvents *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};

class V1_ContextActionAdd : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ContextAction request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_ContextActionAdd(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ContextActionAdd::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ContextActionAdd::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ContextActionAdd::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ContextActionAdd(rpc, service);
		auto fn = ::boost::bind(&V1_ContextActionAdd::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestContextActionAdd(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ContextActionRemove : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ContextAction request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_ContextActionRemove(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ContextActionRemove::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ContextActionRemove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ContextActionRemove::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ContextActionRemove(rpc, service);
		auto fn = ::boost::bind(&V1_ContextActionRemove::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestContextActionRemove(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ContextActionEvents : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ContextAction request;
	::grpc::ServerAsyncWriter < ::MurmurRPC::ContextAction > stream;

	V1_ContextActionEvents(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ContextActionEvents::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	::boost::function<void(bool)> *callback(::boost::function<void(V1_ContextActionEvents *, bool)> cb) {
		auto fn = ::boost::bind(&V1_ContextActionEvents::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void error(const ::grpc::Status &err) {
		stream.Finish(err, this->done());
	}

	void handle(bool ok) {
		V1_ContextActionEvents::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ContextActionEvents::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ContextActionEvents(rpc, service);
		auto fn = ::boost::bind(&V1_ContextActionEvents::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestContextActionEvents(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(V1_ContextActionEvents *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};

class V1_TextMessageSend : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::TextMessage request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_TextMessageSend(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_TextMessageSend::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_TextMessageSend::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_TextMessageSend::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_TextMessageSend(rpc, service);
		auto fn = ::boost::bind(&V1_TextMessageSend::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestTextMessageSend(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_LogQuery : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Log_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Log_List > stream;

	V1_LogQuery(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_LogQuery::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_LogQuery::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_LogQuery::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_LogQuery(rpc, service);
		auto fn = ::boost::bind(&V1_LogQuery::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestLogQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ConfigGet : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Config > stream;

	V1_ConfigGet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ConfigGet::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ConfigGet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ConfigGet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ConfigGet(rpc, service);
		auto fn = ::boost::bind(&V1_ConfigGet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestConfigGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ConfigGetField : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Config_Field request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Config_Field > stream;

	V1_ConfigGetField(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ConfigGetField::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ConfigGetField::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ConfigGetField::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ConfigGetField(rpc, service);
		auto fn = ::boost::bind(&V1_ConfigGetField::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestConfigGetField(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ConfigSetField : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Config_Field request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_ConfigSetField(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ConfigSetField::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ConfigSetField::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ConfigSetField::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ConfigSetField(rpc, service);
		auto fn = ::boost::bind(&V1_ConfigSetField::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestConfigSetField(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ConfigGetDefault : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Config > stream;

	V1_ConfigGetDefault(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ConfigGetDefault::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ConfigGetDefault::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ConfigGetDefault::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ConfigGetDefault(rpc, service);
		auto fn = ::boost::bind(&V1_ConfigGetDefault::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestConfigGetDefault(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ChannelQuery : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel_List > stream;

	V1_ChannelQuery(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ChannelQuery::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ChannelQuery::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ChannelQuery::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ChannelQuery(rpc, service);
		auto fn = ::boost::bind(&V1_ChannelQuery::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestChannelQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ChannelGet : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel > stream;

	V1_ChannelGet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ChannelGet::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ChannelGet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ChannelGet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ChannelGet(rpc, service);
		auto fn = ::boost::bind(&V1_ChannelGet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestChannelGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ChannelAdd : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel > stream;

	V1_ChannelAdd(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ChannelAdd::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ChannelAdd::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ChannelAdd::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ChannelAdd(rpc, service);
		auto fn = ::boost::bind(&V1_ChannelAdd::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestChannelAdd(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ChannelRemove : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_ChannelRemove(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ChannelRemove::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ChannelRemove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ChannelRemove::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ChannelRemove(rpc, service);
		auto fn = ::boost::bind(&V1_ChannelRemove::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestChannelRemove(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ChannelUpdate : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel > stream;

	V1_ChannelUpdate(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ChannelUpdate::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ChannelUpdate::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ChannelUpdate::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ChannelUpdate(rpc, service);
		auto fn = ::boost::bind(&V1_ChannelUpdate::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestChannelUpdate(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_UserQuery : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::User_List > stream;

	V1_UserQuery(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_UserQuery::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_UserQuery::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_UserQuery::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_UserQuery(rpc, service);
		auto fn = ::boost::bind(&V1_UserQuery::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUserQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_UserGet : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::User > stream;

	V1_UserGet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_UserGet::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_UserGet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_UserGet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_UserGet(rpc, service);
		auto fn = ::boost::bind(&V1_UserGet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUserGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_UserUpdate : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::User > stream;

	V1_UserUpdate(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_UserUpdate::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_UserUpdate::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_UserUpdate::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_UserUpdate(rpc, service);
		auto fn = ::boost::bind(&V1_UserUpdate::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUserUpdate(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_UserKick : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User_Kick request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_UserKick(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_UserKick::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_UserKick::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_UserKick::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_UserKick(rpc, service);
		auto fn = ::boost::bind(&V1_UserKick::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUserKick(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_TreeQuery : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Tree_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Tree > stream;

	V1_TreeQuery(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_TreeQuery::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_TreeQuery::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_TreeQuery::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_TreeQuery(rpc, service);
		auto fn = ::boost::bind(&V1_TreeQuery::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestTreeQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_BansGet : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Ban_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Ban_List > stream;

	V1_BansGet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_BansGet::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_BansGet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_BansGet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_BansGet(rpc, service);
		auto fn = ::boost::bind(&V1_BansGet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestBansGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_BansSet : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Ban_List request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_BansSet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_BansSet::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_BansSet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_BansSet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_BansSet(rpc, service);
		auto fn = ::boost::bind(&V1_BansSet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestBansSet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ACLGet : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::ACL_List > stream;

	V1_ACLGet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ACLGet::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ACLGet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ACLGet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ACLGet(rpc, service);
		auto fn = ::boost::bind(&V1_ACLGet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestACLGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ACLSet : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_List request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_ACLSet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ACLSet::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ACLSet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ACLSet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ACLSet(rpc, service);
		auto fn = ::boost::bind(&V1_ACLSet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestACLSet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ACLGetEffectivePermissions : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::ACL > stream;

	V1_ACLGetEffectivePermissions(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ACLGetEffectivePermissions::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ACLGetEffectivePermissions::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ACLGetEffectivePermissions::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ACLGetEffectivePermissions(rpc, service);
		auto fn = ::boost::bind(&V1_ACLGetEffectivePermissions::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestACLGetEffectivePermissions(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ACLAddTemporaryGroup : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_TemporaryGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_ACLAddTemporaryGroup(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ACLAddTemporaryGroup::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ACLAddTemporaryGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ACLAddTemporaryGroup::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ACLAddTemporaryGroup(rpc, service);
		auto fn = ::boost::bind(&V1_ACLAddTemporaryGroup::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestACLAddTemporaryGroup(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ACLRemoveTemporaryGroup : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_TemporaryGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_ACLRemoveTemporaryGroup(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ACLRemoveTemporaryGroup::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_ACLRemoveTemporaryGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ACLRemoveTemporaryGroup::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ACLRemoveTemporaryGroup(rpc, service);
		auto fn = ::boost::bind(&V1_ACLRemoveTemporaryGroup::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestACLRemoveTemporaryGroup(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_AuthenticatorStream : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Authenticator_Response request;
	::MurmurRPC::Authenticator_Request response;
	::grpc::ServerAsyncReaderWriter< ::MurmurRPC::Authenticator_Request, ::MurmurRPC::Authenticator_Response > stream;

	V1_AuthenticatorStream(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	bool write() {
		bool processed = false;
		bool success;
		auto cb = [&success, &processed] (V1_AuthenticatorStream *, bool ok) {
			success = ok;
			processed = true;
		};
		stream.Write(response, callback(cb));
		while (!processed) {
			QCoreApplication::processEvents(QEventLoop::ExcludeSocketNotifiers, 100);
		}
		return success;
	}

	bool read() {
		bool processed = false;
		bool success;
		auto cb = [&success, &processed] (V1_AuthenticatorStream *, bool ok) {
			success = ok;
			processed = true;
		};
		stream.Read(&request, callback(cb));
		while (!processed) {
			QCoreApplication::processEvents(QEventLoop::ExcludeSocketNotifiers, 100);
		}
		return success;
	}

	bool writeRead() {
		return write() && read();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_AuthenticatorStream::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	::boost::function<void(bool)> *callback(::boost::function<void(V1_AuthenticatorStream *, bool)> cb) {
		auto fn = ::boost::bind(&V1_AuthenticatorStream::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void error(const ::grpc::Status &err) {
		stream.Finish(err, this->done());
	}

	void handle(bool ok) {
		V1_AuthenticatorStream::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_AuthenticatorStream::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_AuthenticatorStream(rpc, service);
		auto fn = ::boost::bind(&V1_AuthenticatorStream::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestAuthenticatorStream(&call->context, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(V1_AuthenticatorStream *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};

class V1_DatabaseUserQuery : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser_List > stream;

	V1_DatabaseUserQuery(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_DatabaseUserQuery::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_DatabaseUserQuery::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_DatabaseUserQuery::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_DatabaseUserQuery(rpc, service);
		auto fn = ::boost::bind(&V1_DatabaseUserQuery::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestDatabaseUserQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_DatabaseUserGet : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser > stream;

	V1_DatabaseUserGet(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_DatabaseUserGet::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_DatabaseUserGet::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_DatabaseUserGet::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_DatabaseUserGet(rpc, service);
		auto fn = ::boost::bind(&V1_DatabaseUserGet::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestDatabaseUserGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_DatabaseUserUpdate : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_DatabaseUserUpdate(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_DatabaseUserUpdate::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_DatabaseUserUpdate::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_DatabaseUserUpdate::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_DatabaseUserUpdate(rpc, service);
		auto fn = ::boost::bind(&V1_DatabaseUserUpdate::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestDatabaseUserUpdate(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_DatabaseUserRegister : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser > stream;

	V1_DatabaseUserRegister(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_DatabaseUserRegister::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_DatabaseUserRegister::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_DatabaseUserRegister::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_DatabaseUserRegister(rpc, service);
		auto fn = ::boost::bind(&V1_DatabaseUserRegister::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestDatabaseUserRegister(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_DatabaseUserDeregister : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_DatabaseUserDeregister(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_DatabaseUserDeregister::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_DatabaseUserDeregister::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_DatabaseUserDeregister::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_DatabaseUserDeregister(rpc, service);
		auto fn = ::boost::bind(&V1_DatabaseUserDeregister::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestDatabaseUserDeregister(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_DatabaseUserVerify : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser_Verify request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser > stream;

	V1_DatabaseUserVerify(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_DatabaseUserVerify::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_DatabaseUserVerify::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_DatabaseUserVerify::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_DatabaseUserVerify(rpc, service);
		auto fn = ::boost::bind(&V1_DatabaseUserVerify::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestDatabaseUserVerify(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_RedirectWhisperGroupAdd : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::RedirectWhisperGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_RedirectWhisperGroupAdd(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_RedirectWhisperGroupAdd::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_RedirectWhisperGroupAdd::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_RedirectWhisperGroupAdd::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_RedirectWhisperGroupAdd(rpc, service);
		auto fn = ::boost::bind(&V1_RedirectWhisperGroupAdd::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRedirectWhisperGroupAdd(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_RedirectWhisperGroupRemove : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::RedirectWhisperGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_RedirectWhisperGroupRemove(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_RedirectWhisperGroupRemove::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_RedirectWhisperGroupRemove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_RedirectWhisperGroupRemove::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_RedirectWhisperGroupRemove(rpc, service);
		auto fn = ::boost::bind(&V1_RedirectWhisperGroupRemove::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRedirectWhisperGroupRemove(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void V1_Init(MurmurRPCImpl *impl, ::MurmurRPC::V1::AsyncService *service) {
	V1_GetUptime::create(impl, service);
	V1_GetVersion::create(impl, service);
	V1_Events::create(impl, service);
	V1_ServerCreate::create(impl, service);
	V1_ServerQuery::create(impl, service);
	V1_ServerGet::create(impl, service);
	V1_ServerStart::create(impl, service);
	V1_ServerStop::create(impl, service);
	V1_ServerRemove::create(impl, service);
	V1_ServerEvents::create(impl, service);
	V1_ContextActionAdd::create(impl, service);
	V1_ContextActionRemove::create(impl, service);
	V1_ContextActionEvents::create(impl, service);
	V1_TextMessageSend::create(impl, service);
	V1_LogQuery::create(impl, service);
	V1_ConfigGet::create(impl, service);
	V1_ConfigGetField::create(impl, service);
	V1_ConfigSetField::create(impl, service);
	V1_ConfigGetDefault::create(impl, service);
	V1_ChannelQuery::create(impl, service);
	V1_ChannelGet::create(impl, service);
	V1_ChannelAdd::create(impl, service);
	V1_ChannelRemove::create(impl, service);
	V1_ChannelUpdate::create(impl, service);
	V1_UserQuery::create(impl, service);
	V1_UserGet::create(impl, service);
	V1_UserUpdate::create(impl, service);
	V1_UserKick::create(impl, service);
	V1_TreeQuery::create(impl, service);
	V1_BansGet::create(impl, service);
	V1_BansSet::create(impl, service);
	V1_ACLGet::create(impl, service);
	V1_ACLSet::create(impl, service);
	V1_ACLGetEffectivePermissions::create(impl, service);
	V1_ACLAddTemporaryGroup::create(impl, service);
	V1_ACLRemoveTemporaryGroup::create(impl, service);
	V1_AuthenticatorStream::create(impl, service);
	V1_DatabaseUserQuery::create(impl, service);
	V1_DatabaseUserGet::create(impl, service);
	V1_DatabaseUserUpdate::create(impl, service);
	V1_DatabaseUserRegister::create(impl, service);
	V1_DatabaseUserDeregister::create(impl, service);
	V1_DatabaseUserVerify::create(impl, service);
	V1_RedirectWhisperGroupAdd::create(impl, service);
	V1_RedirectWhisperGroupRemove::create(impl, service);
}

}
}
