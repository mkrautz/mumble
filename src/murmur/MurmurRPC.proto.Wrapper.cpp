// DO NOT EDIT!
// Auto generated by scripts/protoc-gen-grpcwrapper

namespace MurmurRPC {
namespace Wrapper {

class ServerService_Create : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Server > stream;

	ServerService_Create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ServerService_Create::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ServerService_Create::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Create::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Create(rpc, service);
		auto fn = ::boost::bind(&ServerService_Create::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestCreate(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ServerService_Query : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Server_List > stream;

	ServerService_Query(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ServerService_Query::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ServerService_Query::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Query::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Query(rpc, service);
		auto fn = ::boost::bind(&ServerService_Query::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ServerService_Get : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Server > stream;

	ServerService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ServerService_Get::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ServerService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Get::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Get(rpc, service);
		auto fn = ::boost::bind(&ServerService_Get::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ServerService_Start : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	ServerService_Start(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ServerService_Start::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ServerService_Start::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Start::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Start(rpc, service);
		auto fn = ::boost::bind(&ServerService_Start::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestStart(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ServerService_Stop : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	ServerService_Stop(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ServerService_Stop::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ServerService_Stop::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Stop::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Stop(rpc, service);
		auto fn = ::boost::bind(&ServerService_Stop::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestStop(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ServerService_Remove : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	ServerService_Remove(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ServerService_Remove::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ServerService_Remove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Remove::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Remove(rpc, service);
		auto fn = ::boost::bind(&ServerService_Remove::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRemove(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ServerService_Events : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ServerService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncWriter < ::MurmurRPC::Server_Event > stream;

	ServerService_Events(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ServerService_Events::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	::boost::function<void(bool)> *callback(::boost::function<void(ServerService_Events *, bool)> cb) {
		auto fn = ::boost::bind(&ServerService_Events::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void error(const ::grpc::Status &err) {
		stream.Finish(err, this->done());
	}

	void handle(bool ok) {
		ServerService_Events::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ServerService_Events::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ServerService::AsyncService *service) {
		auto call = new ServerService_Events(rpc, service);
		auto fn = ::boost::bind(&ServerService_Events::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestEvents(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(ServerService_Events *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};
void ServerService_Init(MurmurRPCImpl *impl, ::MurmurRPC::ServerService::AsyncService *service) {
	ServerService_Create::create(impl, service);
	ServerService_Query::create(impl, service);
	ServerService_Get::create(impl, service);
	ServerService_Start::create(impl, service);
	ServerService_Stop::create(impl, service);
	ServerService_Remove::create(impl, service);
	ServerService_Events::create(impl, service);
}

class MetaService_GetUptime : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::MetaService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Uptime > stream;

	MetaService_GetUptime(MurmurRPCImpl *rpc, ::MurmurRPC::MetaService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&MetaService_GetUptime::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		MetaService_GetUptime::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&MetaService_GetUptime::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::MetaService::AsyncService *service) {
		auto call = new MetaService_GetUptime(rpc, service);
		auto fn = ::boost::bind(&MetaService_GetUptime::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetUptime(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class MetaService_GetVersion : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::MetaService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Version > stream;

	MetaService_GetVersion(MurmurRPCImpl *rpc, ::MurmurRPC::MetaService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&MetaService_GetVersion::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		MetaService_GetVersion::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&MetaService_GetVersion::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::MetaService::AsyncService *service) {
		auto call = new MetaService_GetVersion(rpc, service);
		auto fn = ::boost::bind(&MetaService_GetVersion::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetVersion(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class MetaService_Events : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::MetaService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncWriter < ::MurmurRPC::Event > stream;

	MetaService_Events(MurmurRPCImpl *rpc, ::MurmurRPC::MetaService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&MetaService_Events::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	::boost::function<void(bool)> *callback(::boost::function<void(MetaService_Events *, bool)> cb) {
		auto fn = ::boost::bind(&MetaService_Events::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void error(const ::grpc::Status &err) {
		stream.Finish(err, this->done());
	}

	void handle(bool ok) {
		MetaService_Events::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&MetaService_Events::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::MetaService::AsyncService *service) {
		auto call = new MetaService_Events(rpc, service);
		auto fn = ::boost::bind(&MetaService_Events::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestEvents(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(MetaService_Events *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};
void MetaService_Init(MurmurRPCImpl *impl, ::MurmurRPC::MetaService::AsyncService *service) {
	MetaService_GetUptime::create(impl, service);
	MetaService_GetVersion::create(impl, service);
	MetaService_Events::create(impl, service);
}

class ContextActionService_Add : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ContextActionService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ContextAction request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	ContextActionService_Add(MurmurRPCImpl *rpc, ::MurmurRPC::ContextActionService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ContextActionService_Add::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ContextActionService_Add::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ContextActionService_Add::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ContextActionService::AsyncService *service) {
		auto call = new ContextActionService_Add(rpc, service);
		auto fn = ::boost::bind(&ContextActionService_Add::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestAdd(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ContextActionService_Remove : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ContextActionService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ContextAction request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	ContextActionService_Remove(MurmurRPCImpl *rpc, ::MurmurRPC::ContextActionService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ContextActionService_Remove::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ContextActionService_Remove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ContextActionService_Remove::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ContextActionService::AsyncService *service) {
		auto call = new ContextActionService_Remove(rpc, service);
		auto fn = ::boost::bind(&ContextActionService_Remove::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRemove(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ContextActionService_Events : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ContextActionService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ContextAction request;
	::grpc::ServerAsyncWriter < ::MurmurRPC::ContextAction > stream;

	ContextActionService_Events(MurmurRPCImpl *rpc, ::MurmurRPC::ContextActionService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ContextActionService_Events::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	::boost::function<void(bool)> *callback(::boost::function<void(ContextActionService_Events *, bool)> cb) {
		auto fn = ::boost::bind(&ContextActionService_Events::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void error(const ::grpc::Status &err) {
		stream.Finish(err, this->done());
	}

	void handle(bool ok) {
		ContextActionService_Events::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ContextActionService_Events::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ContextActionService::AsyncService *service) {
		auto call = new ContextActionService_Events(rpc, service);
		auto fn = ::boost::bind(&ContextActionService_Events::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestEvents(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(ContextActionService_Events *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};
void ContextActionService_Init(MurmurRPCImpl *impl, ::MurmurRPC::ContextActionService::AsyncService *service) {
	ContextActionService_Add::create(impl, service);
	ContextActionService_Remove::create(impl, service);
	ContextActionService_Events::create(impl, service);
}

class TextMessageService_Send : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::TextMessageService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::TextMessage request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	TextMessageService_Send(MurmurRPCImpl *rpc, ::MurmurRPC::TextMessageService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&TextMessageService_Send::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		TextMessageService_Send::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&TextMessageService_Send::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::TextMessageService::AsyncService *service) {
		auto call = new TextMessageService_Send(rpc, service);
		auto fn = ::boost::bind(&TextMessageService_Send::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestSend(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void TextMessageService_Init(MurmurRPCImpl *impl, ::MurmurRPC::TextMessageService::AsyncService *service) {
	TextMessageService_Send::create(impl, service);
}

class LogService_Query : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::LogService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Log_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Log_List > stream;

	LogService_Query(MurmurRPCImpl *rpc, ::MurmurRPC::LogService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&LogService_Query::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		LogService_Query::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&LogService_Query::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::LogService::AsyncService *service) {
		auto call = new LogService_Query(rpc, service);
		auto fn = ::boost::bind(&LogService_Query::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void LogService_Init(MurmurRPCImpl *impl, ::MurmurRPC::LogService::AsyncService *service) {
	LogService_Query::create(impl, service);
}

class ConfigService_Get : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ConfigService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Config > stream;

	ConfigService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ConfigService_Get::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ConfigService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ConfigService_Get::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) {
		auto call = new ConfigService_Get(rpc, service);
		auto fn = ::boost::bind(&ConfigService_Get::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ConfigService_GetField : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ConfigService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Config_Field request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Config_Field > stream;

	ConfigService_GetField(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ConfigService_GetField::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ConfigService_GetField::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ConfigService_GetField::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) {
		auto call = new ConfigService_GetField(rpc, service);
		auto fn = ::boost::bind(&ConfigService_GetField::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetField(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ConfigService_SetField : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ConfigService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Config_Field request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	ConfigService_SetField(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ConfigService_SetField::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ConfigService_SetField::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ConfigService_SetField::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) {
		auto call = new ConfigService_SetField(rpc, service);
		auto fn = ::boost::bind(&ConfigService_SetField::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestSetField(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ConfigService_GetDefaults : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ConfigService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Config > stream;

	ConfigService_GetDefaults(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ConfigService_GetDefaults::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ConfigService_GetDefaults::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ConfigService_GetDefaults::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ConfigService::AsyncService *service) {
		auto call = new ConfigService_GetDefaults(rpc, service);
		auto fn = ::boost::bind(&ConfigService_GetDefaults::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetDefaults(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void ConfigService_Init(MurmurRPCImpl *impl, ::MurmurRPC::ConfigService::AsyncService *service) {
	ConfigService_Get::create(impl, service);
	ConfigService_GetField::create(impl, service);
	ConfigService_SetField::create(impl, service);
	ConfigService_GetDefaults::create(impl, service);
}

class ChannelService_Query : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ChannelService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel_List > stream;

	ChannelService_Query(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ChannelService_Query::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ChannelService_Query::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ChannelService_Query::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) {
		auto call = new ChannelService_Query(rpc, service);
		auto fn = ::boost::bind(&ChannelService_Query::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ChannelService_Get : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ChannelService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel > stream;

	ChannelService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ChannelService_Get::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ChannelService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ChannelService_Get::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) {
		auto call = new ChannelService_Get(rpc, service);
		auto fn = ::boost::bind(&ChannelService_Get::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ChannelService_Add : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ChannelService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel > stream;

	ChannelService_Add(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ChannelService_Add::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ChannelService_Add::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ChannelService_Add::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) {
		auto call = new ChannelService_Add(rpc, service);
		auto fn = ::boost::bind(&ChannelService_Add::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestAdd(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ChannelService_Remove : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ChannelService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	ChannelService_Remove(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ChannelService_Remove::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ChannelService_Remove::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ChannelService_Remove::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) {
		auto call = new ChannelService_Remove(rpc, service);
		auto fn = ::boost::bind(&ChannelService_Remove::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRemove(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ChannelService_Update : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ChannelService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel > stream;

	ChannelService_Update(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ChannelService_Update::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ChannelService_Update::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ChannelService_Update::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ChannelService::AsyncService *service) {
		auto call = new ChannelService_Update(rpc, service);
		auto fn = ::boost::bind(&ChannelService_Update::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUpdate(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void ChannelService_Init(MurmurRPCImpl *impl, ::MurmurRPC::ChannelService::AsyncService *service) {
	ChannelService_Query::create(impl, service);
	ChannelService_Get::create(impl, service);
	ChannelService_Add::create(impl, service);
	ChannelService_Remove::create(impl, service);
	ChannelService_Update::create(impl, service);
}

class UserService_Query : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::UserService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::User_List > stream;

	UserService_Query(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&UserService_Query::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		UserService_Query::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&UserService_Query::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) {
		auto call = new UserService_Query(rpc, service);
		auto fn = ::boost::bind(&UserService_Query::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class UserService_Get : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::UserService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::User > stream;

	UserService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&UserService_Get::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		UserService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&UserService_Get::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) {
		auto call = new UserService_Get(rpc, service);
		auto fn = ::boost::bind(&UserService_Get::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class UserService_Update : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::UserService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::User > stream;

	UserService_Update(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&UserService_Update::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		UserService_Update::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&UserService_Update::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) {
		auto call = new UserService_Update(rpc, service);
		auto fn = ::boost::bind(&UserService_Update::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUpdate(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class UserService_Kick : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::UserService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User_Kick request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	UserService_Kick(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&UserService_Kick::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		UserService_Kick::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&UserService_Kick::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::UserService::AsyncService *service) {
		auto call = new UserService_Kick(rpc, service);
		auto fn = ::boost::bind(&UserService_Kick::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestKick(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void UserService_Init(MurmurRPCImpl *impl, ::MurmurRPC::UserService::AsyncService *service) {
	UserService_Query::create(impl, service);
	UserService_Get::create(impl, service);
	UserService_Update::create(impl, service);
	UserService_Kick::create(impl, service);
}

class TreeService_Query : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::TreeService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Tree_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Tree > stream;

	TreeService_Query(MurmurRPCImpl *rpc, ::MurmurRPC::TreeService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&TreeService_Query::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		TreeService_Query::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&TreeService_Query::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::TreeService::AsyncService *service) {
		auto call = new TreeService_Query(rpc, service);
		auto fn = ::boost::bind(&TreeService_Query::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void TreeService_Init(MurmurRPCImpl *impl, ::MurmurRPC::TreeService::AsyncService *service) {
	TreeService_Query::create(impl, service);
}

class BanService_Get : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::BanService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Ban_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Ban_List > stream;

	BanService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::BanService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&BanService_Get::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		BanService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&BanService_Get::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::BanService::AsyncService *service) {
		auto call = new BanService_Get(rpc, service);
		auto fn = ::boost::bind(&BanService_Get::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class BanService_Set : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::BanService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Ban_List request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	BanService_Set(MurmurRPCImpl *rpc, ::MurmurRPC::BanService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&BanService_Set::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		BanService_Set::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&BanService_Set::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::BanService::AsyncService *service) {
		auto call = new BanService_Set(rpc, service);
		auto fn = ::boost::bind(&BanService_Set::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestSet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void BanService_Init(MurmurRPCImpl *impl, ::MurmurRPC::BanService::AsyncService *service) {
	BanService_Get::create(impl, service);
	BanService_Set::create(impl, service);
}

class ACLService_Get : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ACLService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::ACL_List > stream;

	ACLService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ACLService_Get::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ACLService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ACLService_Get::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) {
		auto call = new ACLService_Get(rpc, service);
		auto fn = ::boost::bind(&ACLService_Get::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ACLService_Set : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ACLService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_List request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	ACLService_Set(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ACLService_Set::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ACLService_Set::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ACLService_Set::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) {
		auto call = new ACLService_Set(rpc, service);
		auto fn = ::boost::bind(&ACLService_Set::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestSet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ACLService_GetEffectivePermissions : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ACLService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::ACL > stream;

	ACLService_GetEffectivePermissions(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ACLService_GetEffectivePermissions::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ACLService_GetEffectivePermissions::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ACLService_GetEffectivePermissions::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) {
		auto call = new ACLService_GetEffectivePermissions(rpc, service);
		auto fn = ::boost::bind(&ACLService_GetEffectivePermissions::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetEffectivePermissions(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ACLService_AddTemporaryGroup : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ACLService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_TemporaryGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	ACLService_AddTemporaryGroup(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ACLService_AddTemporaryGroup::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ACLService_AddTemporaryGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ACLService_AddTemporaryGroup::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) {
		auto call = new ACLService_AddTemporaryGroup(rpc, service);
		auto fn = ::boost::bind(&ACLService_AddTemporaryGroup::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestAddTemporaryGroup(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class ACLService_RemoveTemporaryGroup : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::ACLService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_TemporaryGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	ACLService_RemoveTemporaryGroup(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&ACLService_RemoveTemporaryGroup::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		ACLService_RemoveTemporaryGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&ACLService_RemoveTemporaryGroup::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::ACLService::AsyncService *service) {
		auto call = new ACLService_RemoveTemporaryGroup(rpc, service);
		auto fn = ::boost::bind(&ACLService_RemoveTemporaryGroup::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRemoveTemporaryGroup(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void ACLService_Init(MurmurRPCImpl *impl, ::MurmurRPC::ACLService::AsyncService *service) {
	ACLService_Get::create(impl, service);
	ACLService_Set::create(impl, service);
	ACLService_GetEffectivePermissions::create(impl, service);
	ACLService_AddTemporaryGroup::create(impl, service);
	ACLService_RemoveTemporaryGroup::create(impl, service);
}

class AuthenticatorService_Stream : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::AuthenticatorService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Authenticator_Response request;
	::MurmurRPC::Authenticator_Request response;
	::grpc::ServerAsyncReaderWriter< ::MurmurRPC::Authenticator_Request, ::MurmurRPC::Authenticator_Response > stream;

	AuthenticatorService_Stream(MurmurRPCImpl *rpc, ::MurmurRPC::AuthenticatorService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	bool write() {
		bool processed = false;
		bool success;
		auto cb = [&success, &processed] (AuthenticatorService_Stream *, bool ok) {
			success = ok;
			processed = true;
		};
		stream.Write(response, callback(cb));
		while (!processed) {
			QCoreApplication::processEvents(QEventLoop::ExcludeSocketNotifiers, 100);
		}
		return success;
	}

	bool read() {
		bool processed = false;
		bool success;
		auto cb = [&success, &processed] (AuthenticatorService_Stream *, bool ok) {
			success = ok;
			processed = true;
		};
		stream.Read(&request, callback(cb));
		while (!processed) {
			QCoreApplication::processEvents(QEventLoop::ExcludeSocketNotifiers, 100);
		}
		return success;
	}

	bool writeRead() {
		return write() && read();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&AuthenticatorService_Stream::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	::boost::function<void(bool)> *callback(::boost::function<void(AuthenticatorService_Stream *, bool)> cb) {
		auto fn = ::boost::bind(&AuthenticatorService_Stream::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void error(const ::grpc::Status &err) {
		stream.Finish(err, this->done());
	}

	void handle(bool ok) {
		AuthenticatorService_Stream::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&AuthenticatorService_Stream::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::AuthenticatorService::AsyncService *service) {
		auto call = new AuthenticatorService_Stream(rpc, service);
		auto fn = ::boost::bind(&AuthenticatorService_Stream::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestStream(&call->context, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(AuthenticatorService_Stream *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};
void AuthenticatorService_Init(MurmurRPCImpl *impl, ::MurmurRPC::AuthenticatorService::AsyncService *service) {
	AuthenticatorService_Stream::create(impl, service);
}

class DatabaseService_Query : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser_List > stream;

	DatabaseService_Query(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Query::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		DatabaseService_Query::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Query::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Query(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Query::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQuery(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class DatabaseService_Get : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser > stream;

	DatabaseService_Get(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Get::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		DatabaseService_Get::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Get::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Get(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Get::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGet(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class DatabaseService_Update : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	DatabaseService_Update(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Update::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		DatabaseService_Update::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Update::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Update(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Update::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUpdate(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class DatabaseService_Register : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser > stream;

	DatabaseService_Register(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Register::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		DatabaseService_Register::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Register::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Register(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Register::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRegister(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class DatabaseService_Deregister : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	DatabaseService_Deregister(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Deregister::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		DatabaseService_Deregister::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Deregister::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Deregister(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Deregister::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestDeregister(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class DatabaseService_Verify : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::DatabaseService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser_Verify request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser > stream;

	DatabaseService_Verify(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&DatabaseService_Verify::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		DatabaseService_Verify::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&DatabaseService_Verify::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::DatabaseService::AsyncService *service) {
		auto call = new DatabaseService_Verify(rpc, service);
		auto fn = ::boost::bind(&DatabaseService_Verify::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestVerify(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void DatabaseService_Init(MurmurRPCImpl *impl, ::MurmurRPC::DatabaseService::AsyncService *service) {
	DatabaseService_Query::create(impl, service);
	DatabaseService_Get::create(impl, service);
	DatabaseService_Update::create(impl, service);
	DatabaseService_Register::create(impl, service);
	DatabaseService_Deregister::create(impl, service);
	DatabaseService_Verify::create(impl, service);
}

class AudioService_AddRedirectWhisperGroup : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::AudioService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::RedirectWhisperGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	AudioService_AddRedirectWhisperGroup(MurmurRPCImpl *rpc, ::MurmurRPC::AudioService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&AudioService_AddRedirectWhisperGroup::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		AudioService_AddRedirectWhisperGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&AudioService_AddRedirectWhisperGroup::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::AudioService::AsyncService *service) {
		auto call = new AudioService_AddRedirectWhisperGroup(rpc, service);
		auto fn = ::boost::bind(&AudioService_AddRedirectWhisperGroup::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestAddRedirectWhisperGroup(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class AudioService_RemoveRedirectWhisperGroup : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::AudioService::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::RedirectWhisperGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	AudioService_RemoveRedirectWhisperGroup(MurmurRPCImpl *rpc, ::MurmurRPC::AudioService::AsyncService *service) : rpc(rpc), service(service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		delete this;
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&AudioService_RemoveRedirectWhisperGroup::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		AudioService_RemoveRedirectWhisperGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&AudioService_RemoveRedirectWhisperGroup::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::AudioService::AsyncService *service) {
		auto call = new AudioService_RemoveRedirectWhisperGroup(rpc, service);
		auto fn = ::boost::bind(&AudioService_RemoveRedirectWhisperGroup::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRemoveRedirectWhisperGroup(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void AudioService_Init(MurmurRPCImpl *impl, ::MurmurRPC::AudioService::AsyncService *service) {
	AudioService_AddRedirectWhisperGroup::create(impl, service);
	AudioService_RemoveRedirectWhisperGroup::create(impl, service);
}

}
}
