// DO NOT EDIT!
// Auto generated by scripts/protoc-gen-grpcwrapper

namespace MurmurRPC {
namespace Wrapper {

class V1_GetUptime : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Uptime > stream;

	V1_GetUptime(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_GetUptime::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_GetUptime::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_GetUptime::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_GetUptime(rpc, service);
		auto fn = ::boost::bind(&V1_GetUptime::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetUptime(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_GetVersion : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Version > stream;

	V1_GetVersion(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_GetVersion::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_GetVersion::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_GetVersion::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_GetVersion(rpc, service);
		auto fn = ::boost::bind(&V1_GetVersion::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetVersion(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_Events : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncWriter < ::MurmurRPC::Event > stream;

	V1_Events(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_Events::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	::boost::function<void(bool)> *callback(::boost::function<void(V1_Events *, bool)> cb) {
		auto fn = ::boost::bind(&V1_Events::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void error(const ::grpc::Status &err) {
		stream.Finish(err, this->done());
	}

	void handle(bool ok) {
		V1_Events::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_Events::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_Events(rpc, service);
		auto fn = ::boost::bind(&V1_Events::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestEvents(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(V1_Events *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};

class V1_CreateServer : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Server > stream;

	V1_CreateServer(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_CreateServer::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_CreateServer::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_CreateServer::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_CreateServer(rpc, service);
		auto fn = ::boost::bind(&V1_CreateServer::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestCreateServer(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_QueryServers : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Server_List > stream;

	V1_QueryServers(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_QueryServers::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_QueryServers::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_QueryServers::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_QueryServers(rpc, service);
		auto fn = ::boost::bind(&V1_QueryServers::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQueryServers(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_GetServer : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Server > stream;

	V1_GetServer(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_GetServer::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_GetServer::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_GetServer::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_GetServer(rpc, service);
		auto fn = ::boost::bind(&V1_GetServer::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetServer(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_StartServer : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_StartServer(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_StartServer::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_StartServer::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_StartServer::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_StartServer(rpc, service);
		auto fn = ::boost::bind(&V1_StartServer::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestStartServer(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_StopServer : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_StopServer(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_StopServer::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_StopServer::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_StopServer::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_StopServer(rpc, service);
		auto fn = ::boost::bind(&V1_StopServer::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestStopServer(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_RemoveServer : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_RemoveServer(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_RemoveServer::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_RemoveServer::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_RemoveServer::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_RemoveServer(rpc, service);
		auto fn = ::boost::bind(&V1_RemoveServer::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRemoveServer(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ServerEvents : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncWriter < ::MurmurRPC::Server_Event > stream;

	V1_ServerEvents(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ServerEvents::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	::boost::function<void(bool)> *callback(::boost::function<void(V1_ServerEvents *, bool)> cb) {
		auto fn = ::boost::bind(&V1_ServerEvents::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void error(const ::grpc::Status &err) {
		stream.Finish(err, this->done());
	}

	void handle(bool ok) {
		V1_ServerEvents::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ServerEvents::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ServerEvents(rpc, service);
		auto fn = ::boost::bind(&V1_ServerEvents::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestServerEvents(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(V1_ServerEvents *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};

class V1_AddContextAction : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ContextAction request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_AddContextAction(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_AddContextAction::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_AddContextAction::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_AddContextAction::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_AddContextAction(rpc, service);
		auto fn = ::boost::bind(&V1_AddContextAction::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestAddContextAction(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_RemoveContextAction : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ContextAction request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_RemoveContextAction(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_RemoveContextAction::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_RemoveContextAction::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_RemoveContextAction::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_RemoveContextAction(rpc, service);
		auto fn = ::boost::bind(&V1_RemoveContextAction::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRemoveContextAction(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_ContextActionEvents : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ContextAction request;
	::grpc::ServerAsyncWriter < ::MurmurRPC::ContextAction > stream;

	V1_ContextActionEvents(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_ContextActionEvents::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	::boost::function<void(bool)> *callback(::boost::function<void(V1_ContextActionEvents *, bool)> cb) {
		auto fn = ::boost::bind(&V1_ContextActionEvents::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void error(const ::grpc::Status &err) {
		stream.Finish(err, this->done());
	}

	void handle(bool ok) {
		V1_ContextActionEvents::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_ContextActionEvents::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_ContextActionEvents(rpc, service);
		auto fn = ::boost::bind(&V1_ContextActionEvents::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestContextActionEvents(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(V1_ContextActionEvents *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};

class V1_SendTextMessage : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::TextMessage request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_SendTextMessage(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_SendTextMessage::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_SendTextMessage::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_SendTextMessage::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_SendTextMessage(rpc, service);
		auto fn = ::boost::bind(&V1_SendTextMessage::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestSendTextMessage(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_QueryLogs : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Log_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Log_List > stream;

	V1_QueryLogs(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_QueryLogs::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_QueryLogs::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_QueryLogs::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_QueryLogs(rpc, service);
		auto fn = ::boost::bind(&V1_QueryLogs::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQueryLogs(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_GetConfig : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Server request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Config > stream;

	V1_GetConfig(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_GetConfig::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_GetConfig::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_GetConfig::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_GetConfig(rpc, service);
		auto fn = ::boost::bind(&V1_GetConfig::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetConfig(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_GetConfigField : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Config_Field request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Config_Field > stream;

	V1_GetConfigField(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_GetConfigField::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_GetConfigField::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_GetConfigField::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_GetConfigField(rpc, service);
		auto fn = ::boost::bind(&V1_GetConfigField::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetConfigField(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_SetConfigField : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Config_Field request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_SetConfigField(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_SetConfigField::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_SetConfigField::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_SetConfigField::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_SetConfigField(rpc, service);
		auto fn = ::boost::bind(&V1_SetConfigField::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestSetConfigField(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_GetDefaultConfig : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Void request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Config > stream;

	V1_GetDefaultConfig(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_GetDefaultConfig::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_GetDefaultConfig::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_GetDefaultConfig::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_GetDefaultConfig(rpc, service);
		auto fn = ::boost::bind(&V1_GetDefaultConfig::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetDefaultConfig(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_QueryChannels : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel_List > stream;

	V1_QueryChannels(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_QueryChannels::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_QueryChannels::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_QueryChannels::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_QueryChannels(rpc, service);
		auto fn = ::boost::bind(&V1_QueryChannels::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQueryChannels(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_GetChannel : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel > stream;

	V1_GetChannel(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_GetChannel::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_GetChannel::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_GetChannel::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_GetChannel(rpc, service);
		auto fn = ::boost::bind(&V1_GetChannel::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetChannel(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_AddChannel : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel > stream;

	V1_AddChannel(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_AddChannel::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_AddChannel::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_AddChannel::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_AddChannel(rpc, service);
		auto fn = ::boost::bind(&V1_AddChannel::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestAddChannel(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_RemoveChannel : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_RemoveChannel(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_RemoveChannel::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_RemoveChannel::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_RemoveChannel::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_RemoveChannel(rpc, service);
		auto fn = ::boost::bind(&V1_RemoveChannel::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRemoveChannel(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_UpdateChannel : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Channel > stream;

	V1_UpdateChannel(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_UpdateChannel::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_UpdateChannel::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_UpdateChannel::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_UpdateChannel(rpc, service);
		auto fn = ::boost::bind(&V1_UpdateChannel::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUpdateChannel(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_QueryUsers : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::User_List > stream;

	V1_QueryUsers(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_QueryUsers::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_QueryUsers::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_QueryUsers::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_QueryUsers(rpc, service);
		auto fn = ::boost::bind(&V1_QueryUsers::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQueryUsers(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_GetUser : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::User > stream;

	V1_GetUser(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_GetUser::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_GetUser::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_GetUser::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_GetUser(rpc, service);
		auto fn = ::boost::bind(&V1_GetUser::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetUser(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_UpdateUser : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::User > stream;

	V1_UpdateUser(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_UpdateUser::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_UpdateUser::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_UpdateUser::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_UpdateUser(rpc, service);
		auto fn = ::boost::bind(&V1_UpdateUser::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUpdateUser(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_KickUser : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::User_Kick request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_KickUser(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_KickUser::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_KickUser::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_KickUser::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_KickUser(rpc, service);
		auto fn = ::boost::bind(&V1_KickUser::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestKickUser(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_QueryTree : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Tree_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Tree > stream;

	V1_QueryTree(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_QueryTree::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_QueryTree::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_QueryTree::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_QueryTree(rpc, service);
		auto fn = ::boost::bind(&V1_QueryTree::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQueryTree(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_GetBans : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Ban_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Ban_List > stream;

	V1_GetBans(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_GetBans::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_GetBans::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_GetBans::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_GetBans(rpc, service);
		auto fn = ::boost::bind(&V1_GetBans::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetBans(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_SetBans : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Ban_List request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_SetBans(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_SetBans::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_SetBans::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_SetBans::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_SetBans(rpc, service);
		auto fn = ::boost::bind(&V1_SetBans::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestSetBans(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_GetACL : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Channel request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::ACL_List > stream;

	V1_GetACL(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_GetACL::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_GetACL::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_GetACL::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_GetACL(rpc, service);
		auto fn = ::boost::bind(&V1_GetACL::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetACL(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_SetACL : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_List request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_SetACL(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_SetACL::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_SetACL::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_SetACL::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_SetACL(rpc, service);
		auto fn = ::boost::bind(&V1_SetACL::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestSetACL(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_GetEffectivePermissions : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::ACL > stream;

	V1_GetEffectivePermissions(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_GetEffectivePermissions::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_GetEffectivePermissions::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_GetEffectivePermissions::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_GetEffectivePermissions(rpc, service);
		auto fn = ::boost::bind(&V1_GetEffectivePermissions::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetEffectivePermissions(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_AddTemporaryGroup : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_TemporaryGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_AddTemporaryGroup(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_AddTemporaryGroup::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_AddTemporaryGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_AddTemporaryGroup::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_AddTemporaryGroup(rpc, service);
		auto fn = ::boost::bind(&V1_AddTemporaryGroup::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestAddTemporaryGroup(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_RemoveTemporaryGroup : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::ACL_TemporaryGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_RemoveTemporaryGroup(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_RemoveTemporaryGroup::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_RemoveTemporaryGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_RemoveTemporaryGroup::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_RemoveTemporaryGroup(rpc, service);
		auto fn = ::boost::bind(&V1_RemoveTemporaryGroup::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRemoveTemporaryGroup(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_AuthenticatorStream : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::Authenticator_Response request;
	::MurmurRPC::Authenticator_Request response;
	::grpc::ServerAsyncReaderWriter< ::MurmurRPC::Authenticator_Request, ::MurmurRPC::Authenticator_Response > stream;

	V1_AuthenticatorStream(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	bool write() {
		bool processed = false;
		bool success;
		auto cb = [&success, &processed] (V1_AuthenticatorStream *, bool ok) {
			success = ok;
			processed = true;
		};
		stream.Write(response, callback(cb));
		while (!processed) {
			QCoreApplication::processEvents(QEventLoop::ExcludeSocketNotifiers, 100);
		}
		return success;
	}

	bool read() {
		bool processed = false;
		bool success;
		auto cb = [&success, &processed] (V1_AuthenticatorStream *, bool ok) {
			success = ok;
			processed = true;
		};
		stream.Read(&request, callback(cb));
		while (!processed) {
			QCoreApplication::processEvents(QEventLoop::ExcludeSocketNotifiers, 100);
		}
		return success;
	}

	bool writeRead() {
		return write() && read();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_AuthenticatorStream::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	::boost::function<void(bool)> *callback(::boost::function<void(V1_AuthenticatorStream *, bool)> cb) {
		auto fn = ::boost::bind(&V1_AuthenticatorStream::callbackAction, this, cb, _1);
		return new ::boost::function<void(bool)>(fn);
	}

	void error(const ::grpc::Status &err) {
		stream.Finish(err, this->done());
	}

	void handle(bool ok) {
		V1_AuthenticatorStream::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_AuthenticatorStream::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_AuthenticatorStream(rpc, service);
		auto fn = ::boost::bind(&V1_AuthenticatorStream::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestAuthenticatorStream(&call->context, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}

private:

	void callbackAction(::boost::function<void(V1_AuthenticatorStream *, bool)> cb, bool ok) {
		auto ie = new RPCExecEvent(::boost::bind(cb, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}
};

class V1_QueryDatabaseUsers : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser_Query request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser_List > stream;

	V1_QueryDatabaseUsers(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_QueryDatabaseUsers::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_QueryDatabaseUsers::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_QueryDatabaseUsers::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_QueryDatabaseUsers(rpc, service);
		auto fn = ::boost::bind(&V1_QueryDatabaseUsers::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestQueryDatabaseUsers(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_GetDatabaseUser : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser > stream;

	V1_GetDatabaseUser(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_GetDatabaseUser::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_GetDatabaseUser::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_GetDatabaseUser::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_GetDatabaseUser(rpc, service);
		auto fn = ::boost::bind(&V1_GetDatabaseUser::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestGetDatabaseUser(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_UpdateDatabaseUser : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_UpdateDatabaseUser(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_UpdateDatabaseUser::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_UpdateDatabaseUser::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_UpdateDatabaseUser::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_UpdateDatabaseUser(rpc, service);
		auto fn = ::boost::bind(&V1_UpdateDatabaseUser::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestUpdateDatabaseUser(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_RegisterDatabaseUser : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser > stream;

	V1_RegisterDatabaseUser(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_RegisterDatabaseUser::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_RegisterDatabaseUser::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_RegisterDatabaseUser::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_RegisterDatabaseUser(rpc, service);
		auto fn = ::boost::bind(&V1_RegisterDatabaseUser::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRegisterDatabaseUser(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_DeregisterDatabaseUser : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_DeregisterDatabaseUser(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_DeregisterDatabaseUser::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_DeregisterDatabaseUser::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_DeregisterDatabaseUser::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_DeregisterDatabaseUser(rpc, service);
		auto fn = ::boost::bind(&V1_DeregisterDatabaseUser::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestDeregisterDatabaseUser(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_VerifyDatabaseUser : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::DatabaseUser_Verify request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::DatabaseUser > stream;

	V1_VerifyDatabaseUser(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_VerifyDatabaseUser::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_VerifyDatabaseUser::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_VerifyDatabaseUser::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_VerifyDatabaseUser(rpc, service);
		auto fn = ::boost::bind(&V1_VerifyDatabaseUser::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestVerifyDatabaseUser(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_AddRedirectWhisperGroup : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::RedirectWhisperGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_AddRedirectWhisperGroup(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_AddRedirectWhisperGroup::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_AddRedirectWhisperGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_AddRedirectWhisperGroup::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_AddRedirectWhisperGroup(rpc, service);
		auto fn = ::boost::bind(&V1_AddRedirectWhisperGroup::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestAddRedirectWhisperGroup(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};

class V1_RemoveRedirectWhisperGroup : public RPCCall {
public:
	MurmurRPCImpl *rpc;
	::MurmurRPC::V1::AsyncService *service;

	::grpc::ServerContext context;
	::MurmurRPC::RedirectWhisperGroup request;
	::grpc::ServerAsyncResponseWriter < ::MurmurRPC::Void > stream;

	V1_RemoveRedirectWhisperGroup(MurmurRPCImpl *rpc_impl, ::MurmurRPC::V1::AsyncService *async_service) : rpc(rpc_impl), service(async_service), stream(&context) {
	}

	void impl(bool ok);

	void finish(bool) {
		deref();
	}

	::boost::function<void(bool)> *done() {
		auto done_fn = ::boost::bind(&V1_RemoveRedirectWhisperGroup::finish, this, _1);
		return new ::boost::function<void(bool)>(done_fn);
	}

	void error(const ::grpc::Status &err) {
		stream.FinishWithError(err, this->done());
	}

	void handle(bool ok) {
		V1_RemoveRedirectWhisperGroup::create(this->rpc, this->service);
		auto ie = new RPCExecEvent(::boost::bind(&V1_RemoveRedirectWhisperGroup::impl, this, ok), this);
		QCoreApplication::instance()->postEvent(rpc, ie);
	}

	static void create(MurmurRPCImpl *rpc, ::MurmurRPC::V1::AsyncService *service) {
		auto call = new V1_RemoveRedirectWhisperGroup(rpc, service);
		auto fn = ::boost::bind(&V1_RemoveRedirectWhisperGroup::handle, call, _1);
		auto fn_ptr = new ::boost::function<void(bool)>(fn);
		service->RequestRemoveRedirectWhisperGroup(&call->context, &call->request, &call->stream, rpc->mCQ.get(), rpc->mCQ.get(), fn_ptr);
	}
};
void V1_Init(MurmurRPCImpl *impl, ::MurmurRPC::V1::AsyncService *service) {
	V1_GetUptime::create(impl, service);
	V1_GetVersion::create(impl, service);
	V1_Events::create(impl, service);
	V1_CreateServer::create(impl, service);
	V1_QueryServers::create(impl, service);
	V1_GetServer::create(impl, service);
	V1_StartServer::create(impl, service);
	V1_StopServer::create(impl, service);
	V1_RemoveServer::create(impl, service);
	V1_ServerEvents::create(impl, service);
	V1_AddContextAction::create(impl, service);
	V1_RemoveContextAction::create(impl, service);
	V1_ContextActionEvents::create(impl, service);
	V1_SendTextMessage::create(impl, service);
	V1_QueryLogs::create(impl, service);
	V1_GetConfig::create(impl, service);
	V1_GetConfigField::create(impl, service);
	V1_SetConfigField::create(impl, service);
	V1_GetDefaultConfig::create(impl, service);
	V1_QueryChannels::create(impl, service);
	V1_GetChannel::create(impl, service);
	V1_AddChannel::create(impl, service);
	V1_RemoveChannel::create(impl, service);
	V1_UpdateChannel::create(impl, service);
	V1_QueryUsers::create(impl, service);
	V1_GetUser::create(impl, service);
	V1_UpdateUser::create(impl, service);
	V1_KickUser::create(impl, service);
	V1_QueryTree::create(impl, service);
	V1_GetBans::create(impl, service);
	V1_SetBans::create(impl, service);
	V1_GetACL::create(impl, service);
	V1_SetACL::create(impl, service);
	V1_GetEffectivePermissions::create(impl, service);
	V1_AddTemporaryGroup::create(impl, service);
	V1_RemoveTemporaryGroup::create(impl, service);
	V1_AuthenticatorStream::create(impl, service);
	V1_QueryDatabaseUsers::create(impl, service);
	V1_GetDatabaseUser::create(impl, service);
	V1_UpdateDatabaseUser::create(impl, service);
	V1_RegisterDatabaseUser::create(impl, service);
	V1_DeregisterDatabaseUser::create(impl, service);
	V1_VerifyDatabaseUser::create(impl, service);
	V1_AddRedirectWhisperGroup::create(impl, service);
	V1_RemoveRedirectWhisperGroup::create(impl, service);
}

}
}
