syntax = "proto2";

package MurmurRPC;

message Void {
}

message Version {
	// 2-byte Major, 1-byte Minor and 1-byte Patch version number.
	optional uint32 version = 1;
	// Client release name.
	optional string release = 2;
	// Client OS name.
	optional string os = 3;
	// Client OS version.
	optional string os_version = 4;
}

message Uptime {
	optional uint64 secs = 1;
}

message Server {
	required uint32 id = 1;
	optional bool running = 2;
	optional uint32 uptime = 3;

	message Event {
		enum Type {
			UserConnected = 0;
			UserDisconnected = 1;
			UserStateChanged = 2;
			UserTextMessage = 3;
			ChannelCreated = 4;
			ChannelRemoved = 5;
			ChannelStateChanged = 6;
		};
		optional Server server = 1;
		optional Type type = 2;
		optional User user = 3;
		optional TextMessage message = 4;
		optional Channel channel = 5;
	}

	message Query {
	}
}

service ServerService {
	rpc create(Void) returns(Server);

	rpc query(Server.Query) returns(stream Server);
	rpc get(Server) returns(Server);

	rpc start(Server) returns(Void);
	rpc stop(Server) returns(Void);
	rpc remove(Server) returns(Void);

	rpc events(Server) returns(stream Server.Event);
}

message Event {
	enum Type {
		ServerStarted = 0;
		ServerStopped = 1;
	};
	optional Type type = 1;
	optional Server server = 2;
}

service MetaService {
	// Get murmur's uptime.
	rpc uptime(Void) returns(Uptime);
	// Get murmur's version.
	rpc version(Void) returns(Version);
	rpc events(Void) returns(stream Event);
}

message ContextAction {
	enum Context {
		None = 0x00;
		Server = 0x01;
		Channel = 0x02;
		Users = 0x04;
	};

	optional Server server = 1;

	optional Context context = 2;
	optional string action = 3;
	optional User actor = 4;
	optional User user = 5;
	optional Channel channel = 6;
}

service ContextActionService {
	rpc add(ContextAction) returns(Void);
	rpc remove(ContextAction) returns(Void);
	rpc events(ContextAction) returns(stream ContextAction);
}

message TextMessage {
	optional Server server = 1;

	optional User actor = 2;
	repeated User users = 3;
	repeated Channel channels = 4;
	repeated Channel trees = 5;
	optional string text = 6;
}

service TextMessageService {
	// If users, channels, and trees are not set in the TextMessage, the message
	// will be broadcast the entire server.
	rpc send(TextMessage) returns(Void);
	// FEATURE: add "rpc filter(stream TextMessage) returns(stream TextMessage)"
}

message Log {
	message Entry {
		optional Server server = 1;
		optional int64 timestamp = 2;
		optional string text = 3;
	}

	message Query {
		optional Server server = 1;
		optional int64 start_timestamp = 2;
		optional int64 end_timestamp = 3;
		optional uint32 limit = 4;
	}
}

service LogService {
	rpc query(Log.Query) returns(stream Log.Entry);
}

// Having "Config" seems preferable to having a map (map<string, string>),
// since. we are able to get some type safety. The downside to this is that
// arbitrary config values cannot be set (i.e. a user cannot set the "county"
// config value without changing the protocol buffer on both the client and
// server).
message Config {
	optional Server server = 55; // TODO: reindex

	optional string password = 1;
	optional uint32 timeout = 2;
	optional uint32 bandwidth = 3;
	optional uint32 users = 4;
	optional uint32 users_per_channel = 5;
	optional uint32 text_message_length = 6;
	optional uint32 image_message_length = 7;
	optional bool allow_help = 8;
	optional Channel default_channel = 9;
	optional bool remember_channel = 10;
	optional string welcome_text = 11;

	optional string register_name = 12;
	optional string register_password = 13;
	optional string register_hostname = 14;
	optional string register_location = 15;
	optional string register_url = 16;

	optional bool cert_required = 17;
	optional bool force_external_auth = 18;
	optional bool bonjour = 19;
	optional bool allow_ping = 20;

	optional string username = 21;
	optional string channelname = 22;

	optional Version suggest_version = 23;
	optional bool suggest_positional = 24;
	optional bool suggest_push_to_talk = 25;

	optional uint32 opus_threshold = 26;
	optional uint32 channel_nesting_limit = 27;

	message Query {
		optional Server server = 1;
	}
}

service ConfigService {
	rpc get(Void) returns(Config);
	rpc setDefault(Config) returns(Void);
	rpc query(Config.Query) returns(Config); // TODO: Remove in favor of a field in "Server"?
}

message Channel {
	optional Server server = 1;

	optional uint32 id = 2;
	optional string name = 3;
	optional uint32 parent = 4;
	repeated Channel links = 5;
	optional string description = 6;
	optional bool temporary = 7;
	optional int32 position = 8;

	message Query {
		optional Server server = 1;
	}
}

service ChannelService {
	rpc query(Channel.Query) returns(stream Channel);
	rpc get(Channel) returns(Channel);

	rpc add(Channel) returns(Channel);
	rpc remove(Channel) returns(Void);
	rpc update(Channel) returns(Channel);
}

message User {
	optional Server server = 50; // TODO: reindex

	optional uint32 session = 1;
	optional uint32 id = 2;

	optional bool mute = 3;
	optional bool deaf = 4;
	optional bool suppress = 5;
	optional bool priority_speaker = 6;
	optional bool self_mute = 7;
	optional bool self_deaf = 8;
	optional bool recording = 9;
	optional Channel channel = 10;
	optional string name = 11;
	optional uint32 online_secs = 12;
	optional uint32 idle_secs = 13;
	optional uint32 bytes_per_sec = 14;
	optional Version version = 15;

	optional bytes plugin_context = 16;
	optional string plugin_identity = 17;

	optional string comment = 18;
	optional bytes texture = 19;
	optional bytes address = 20;
	optional bool tcp_only = 21;

	optional float udp_ping = 22;
	optional float tcp_ping = 23;

	message Query {
		optional Server server = 1;
	}

	message Kick {
		optional Server server = 1;
		optional User user = 2;
		optional string reason = 3;
	}
}

service UserService {
	rpc query(User.Query) returns(stream User);
	// Get returns information on the user, given by the user's session or name.
	rpc get(User) returns(User);
	rpc update(User) returns(User);

	rpc kick(User.Kick) returns(Void);
	// FEATURE: rpc ban(User.Ban) returns(Void);
}

message Tree {
	optional Server server = 1;

	optional Channel channel = 2;
	repeated Channel children = 3;
	repeated User users = 4;
}

service TreeService {
	// Worth considering this: http://stackoverflow.com/a/5945674 ?
	rpc get(Tree) returns(Tree);
}

message Ban {
	optional Server server = 1;

	optional bytes address = 2;
	optional uint32 bits = 3;
	optional string name = 4;
	optional string hash = 5;
	optional string reason = 6;
	optional int64 start = 7;
	optional int64 duration = 8;
}

service BanService {
	rpc get(Ban) returns(stream Ban);
	rpc set(stream Ban) returns(Void);
}

message ACL {
	enum Permission {
		None = 0x00;
		Write = 0x01;
		Traverse = 0x02;
		Enter = 0x04;
		Speak = 0x08;
		Whisper = 0x100;
		MuteDeafen = 0x10;
		Move = 0x20;
		MakeChannel = 0x40;
		MakeTemporaryChannel = 0x400;
		LinkChannel = 0x80;
		TextMessage = 0x200;

		Kick = 0x10000;
		Ban = 0x20000;
		Register = 0x40000;
		RegisterSelf = 0x80000;
	}

	message Group {
		optional string name = 1;
		optional bool inherited = 2;
		optional bool inherit = 3;
		optional bool inheritable = 4;

		repeated Database.User users_add = 5;
		repeated Database.User users_remove = 6;
		repeated Database.User users = 7;
	}

	optional bool apply_here = 3;
	optional bool apply_subs = 4;
	optional bool inherited = 5;

	optional Database.User user = 6;
	optional string group = 7;

	optional Permission allow = 8;
	optional Permission deny = 9;

	// TODO: need a better name than "List"
	message List {
		optional Server server = 1;
		optional Channel channel = 2;

		repeated ACL acls = 3;
		repeated string groups = 4;
		optional bool inherit = 5;
	}

	message TemporaryGroup {
		optional Server server = 1;

		optional Channel channel = 2;
		optional User user = 3;
		optional string group = 4;
	}
}

service ACLService {
	rpc get(Channel) returns(ACL.List);
	rpc set(ACL.List) returns(Void);

	rpc effectivePermissions(User) returns(ACL);

	rpc addTemporaryGroup(ACL.TemporaryGroup) returns(Void);
	rpc removeTemporaryGroup(ACL.TemporaryGroup) returns(Void);
}

message Authenticator {
	message Message {
		enum Type {
			Initialize = 0;
			Authenticate = 1;
			AuthenticateTemporaryFailure = 2;
			AuthenticateFailure = 3;
			Information = 4;

			// Below types are only sent when "registrationStream" used.
			Register = 5;
			Unregister = 6;
			Update = 7;
			Query = 8;
		}

		optional Server server = 1;

		optional Type type = 2;
		optional User user = 3;
		repeated Database.User database_user = 4;
		repeated string groups = 5;
	}
}

service AuthenticatorService {
	// an initial Authenticator.Response with the "server" set needs to be sent
	// before requests start coming in.
	rpc stream(stream Authenticator.Message) returns(stream Authenticator.Message);

	// same as "stream", but accepts updated registration information.
	rpc registrationStream(stream Authenticator.Message) returns(stream Authenticator.Message);
}

message Database {
	message Query {
		optional Server server = 1;
	}

	message VerifyPassword {
		optional Server server = 1;
		optional string username = 2;
		optional string password  = 3;
	}

	message User {
		optional Server server = 1;

		optional uint32 id = 2;
		optional string name = 3;
		optional string email = 4;
		optional string comment = 5;
		optional string hash = 6;
		optional string password = 7;
		optional string last_active = 8;
		optional bytes texture = 9;
	}
}

service DatabaseService {
	rpc query(Database.Query) returns(stream Database.User);
	rpc get(Database.User) returns(Database.User);
	rpc update(Database.User) returns(Database.User);
	// TODO(grpc): "register" currently cannot be used as a name
	rpc registerFIXME(Database.User) returns(Database.User);
	rpc deregister(Database.User) returns(Void);
	rpc verifyPassword(Database.VerifyPassword) returns(Database.User);
}

message RedirectWhisperGroup {
	optional Server server = 1;

	optional User user = 2;
	optional string source = 3;
	optional string target = 4;
}

service AudioService {
	rpc redirectWhisperGroup(RedirectWhisperGroup) returns(Void);
}
