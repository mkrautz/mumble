syntax = "proto2";

package MurmurRPC;

// TODO(grpc): ensure all service methods are named as actions (e.g. "Get...")

message Void {
}

message Version {
	// 2-byte Major, 1-byte Minor and 1-byte Patch version number.
	optional uint32 version = 1;
	// Client release name.
	optional string release = 2;
	// Client OS name.
	optional string os = 3;
	// Client OS version.
	optional string os_version = 4;
}

message Uptime {
	optional uint64 secs = 1;
}

message Server {
	required uint32 id = 1;
	optional bool running = 2;
	optional uint32 uptime = 3;

	message Event {
		enum Type {
			UserConnected = 0;
			UserDisconnected = 1;
			UserStateChanged = 2;
			UserTextMessage = 3;
			ChannelCreated = 4;
			ChannelRemoved = 5;
			ChannelStateChanged = 6;
		};
		optional Server server = 1;
		optional Type type = 2;
		optional User user = 3;
		optional TextMessage message = 4;
		optional Channel channel = 5;
	}

	message Query {
	}

	message List {
		repeated Server servers = 1;
	}
}

service ServerService {
	// Create creates a new virtual server.
	rpc Create(Void) returns(Server);

	// Query returns a list of servers that match the given query.
	rpc Query(Server.Query) returns(Server.List);
	// Get returns information about the given server.
	rpc Get(Server) returns(Server);

	// Start starts the given stopped server.
	rpc Start(Server) returns(Void);
	// Stop stops the given virtual server.
	rpc Stop(Server) returns(Void);
	// Remove removes the given virtual server and its configuration.
	rpc Remove(Server) returns(Void);

	// Events returns a stream of events that happen on the given server.
	rpc Events(Server) returns(stream Server.Event);
}

message Event {
	enum Type {
		ServerStopped = 0;
		ServerStarted = 1;
	};
	optional Type type = 1;
	optional Server server = 2;
}

service MetaService {
	// GetUptime returns murmur's uptime.
	rpc GetUptime(Void) returns(Uptime);
	// GetVersion returns murmur's version.
	rpc GetVersion(Void) returns(Version);
	// Events returns a stream of murmur events.
	rpc Events(Void) returns(stream Event);
}

message ContextAction {
	enum Context {
		None = 0x00;
		Server = 0x01;
		Channel = 0x02;
		User = 0x04;
	};

	optional Server server = 1;

	optional Context context = 2;
	optional string action = 3;
	optional string text = 4;
	optional User actor = 5;
	optional User user = 6;
	optional Channel channel = 7;
}

service ContextActionService {
	// Add adds a context action to the given user's client. Fields must be set:
	//   context, action, text, and user.
	rpc Add(ContextAction) returns(Void);
	// Remove removes a context action from the given user's client. Fields must
	// be set:
	//   action
	// If no user is given, the context action is removed from all users.
	rpc Remove(ContextAction) returns(Void);
	// Events returns a stream of context action events that are triggered by
	// users.
	rpc Events(ContextAction) returns(stream ContextAction);
}

message TextMessage {
	optional Server server = 1;

	optional User actor = 2;
	repeated User users = 3;
	repeated Channel channels = 4;
	repeated Channel trees = 5;
	optional string text = 6;
}

service TextMessageService {
	// Send sends the given TextMessage to the server.
	//
	// If users, channels, and trees are not set in the TextMessage, the message
	// will be broadcast the entire server. Otherwise, the message will be
	// targeted to the specified users, channels, and trees.
	rpc Send(TextMessage) returns(Void);
	// FEATURE: add "rpc filter(stream TextMessage) returns(stream TextMessage)"
}

message Log {
	optional Server server = 1;

	optional int64 timestamp = 2;
	optional string text = 3;

	message Query {
		optional Server server = 1;
		optional uint32 min = 2;
		optional uint32 max = 3;
	}

	message List {
		optional Server server = 1;
		optional uint32 total = 2;
		optional uint32 min = 3;
		optional uint32 max = 4;
		repeated Log entries = 5;
	}
}

service LogService {
	// Query returns a list of log entries from the given server.
	//
	// To get the total number of log entries, omit min and/or max from the
	// query.
	rpc Query(Log.Query) returns(Log.List);
}

message Config {
	optional Server server = 1;
	map<string, string> fields = 2;

	message Field {
		optional Server server = 1;
		optional string key = 2;
		optional string value = 3;
	}
}

service ConfigService {
	// Get returns the explicitly set configuration for the given server.
	rpc Get(Server) returns(Config);
	// GetField returns the configuration value for the given key.
	rpc GetField(Config.Field) returns(Config.Field);
	// SetField sets the configuration value to the given value.
	rpc SetField(Config.Field) returns(Void);

	// GetDefaults returns the default server configuration.
	rpc GetDefaults(Void) returns(Config);
}

message Channel {
	optional Server server = 1;

	optional uint32 id = 2;
	optional string name = 3;
	optional Channel parent = 4;
	repeated Channel links = 5;
	optional string description = 6;
	optional bool temporary = 7;
	optional int32 position = 8;

	message Query {
		optional Server server = 1;
	}

	message List {
		optional Server server = 1;
		repeated Channel channels = 2;
	}
}

service ChannelService {
	// Query returns a list of channels that match the given query.
	rpc Query(Channel.Query) returns(Channel.List);
	// Get returns the channel with the given ID.
	rpc Get(Channel) returns(Channel);

	// Add adds the channel to the given server. The parent and name of the
	// channel must be set.
	rpc Add(Channel) returns(Channel);
	// Remove removes the given channel from the server.
	rpc Remove(Channel) returns(Void);
	// Update updates the given channel's attributes. Only the fields that are
	// set will be updated.
	rpc Update(Channel) returns(Channel);
}

message User {
	optional Server server = 50; // TODO: reindex

	optional uint32 session = 1;
	optional uint32 id = 2;
	optional string name = 11;

	optional bool mute = 3;
	optional bool deaf = 4;
	optional bool suppress = 5;
	optional bool priority_speaker = 6;
	optional bool self_mute = 7;
	optional bool self_deaf = 8;
	optional bool recording = 9;
	optional Channel channel = 10;
	optional uint32 online_secs = 12;
	optional uint32 idle_secs = 13;
	optional uint32 bytes_per_sec = 14;
	optional Version version = 15;

	optional bytes plugin_context = 16;
	optional string plugin_identity = 17;

	optional string comment = 18;
	optional bytes texture = 19;
	optional bytes address = 20;
	optional bool tcp_only = 21;

	optional float udp_ping = 22;
	optional float tcp_ping = 23;

	message Query {
		optional Server server = 1;
	}

	message List {
		optional Server server = 1;
		repeated User users = 2;
	}

	message Kick {
		// TODO(grpc): server is not really required here, since it's embedded in
		// user.
		optional Server server = 1;
		optional User user = 2;
		optional string reason = 3;
	}
}

service UserService {
	// Query returns a list of connected users who match the given query.
	rpc Query(User.Query) returns(User.List);
	// Get returns information on the connected user, given by the user's session
	// or name.
	rpc Get(User) returns(User);
	// Update changes the given user's state. Only the following fields can be
	// changed:
	//   name, mute, deaf, suppress, priority_speaker, channel, comment.
	rpc Update(User) returns(User);

	// Kick kicks the user from the server.
	rpc Kick(User.Kick) returns(Void);
	// FEATURE: rpc ban(User.Ban) returns(Void);
}

message Tree {
	optional Server server = 1;

	optional Channel channel = 2;
	repeated Tree children = 3;
	repeated User users = 4;
}

service TreeService {
	// Get returns a representation of the server's channel/user tree.
	rpc Get(Server) returns(Tree);
}

message Ban {
	optional Server server = 1;

	optional bytes address = 2;
	optional uint32 bits = 3;
	optional string name = 4;
	optional string hash = 5;
	optional string reason = 6;
	optional int64 start = 7;
	optional int64 duration = 8;

	message Query {
		optional Server server = 1;
	}

	message List {
		optional Server server = 1;
		repeated Ban bans = 2;
	}
}

service BanService {
	// Get returns a list of bans for the given server.
	rpc Get(Ban.Query) returns(Ban.List);
	// Set replaces the server's ban list with the given list.
	rpc Set(Ban.List) returns(Void);
}

message ACL {
	enum Permission {
		None = 0x00;
		Write = 0x01;
		Traverse = 0x02;
		Enter = 0x04;
		Speak = 0x08;
		Whisper = 0x100;
		MuteDeafen = 0x10;
		Move = 0x20;
		MakeChannel = 0x40;
		MakeTemporaryChannel = 0x400;
		LinkChannel = 0x80;
		TextMessage = 0x200;

		Kick = 0x10000;
		Ban = 0x20000;
		Register = 0x40000;
		RegisterSelf = 0x80000;
	}

	message Group {
		optional string name = 1;
		optional bool inherited = 2;
		optional bool inherit = 3;
		optional bool inheritable = 4;

		repeated DatabaseUser users_add = 5;
		repeated DatabaseUser users_remove = 6;
		repeated DatabaseUser users = 7;
	}

	optional bool apply_here = 3;
	optional bool apply_subs = 4;
	optional bool inherited = 5;

	optional DatabaseUser user = 6;
	optional string group = 7; // TODO(grpc): change to ACL.Group?

	optional Permission allow = 8;
	optional Permission deny = 9;

	message Query {
		optional Server server = 1;
		optional User user = 2;
		optional Channel channel = 3;
	}

	message List {
		optional Server server = 1;
		optional Channel channel = 2;

		repeated ACL acls = 3;
		repeated ACL.Group groups = 4;
		optional bool inherit = 5;
	}

	message TemporaryGroup {
		optional Server server = 1;

		optional Channel channel = 2;
		optional User user = 3;
		optional string group_name = 4;
	}
}

service ACLService {
	// Get returns the ACL for the given channel.
	rpc Get(Channel) returns(ACL.List);
	// Set overrides the ACL of the given channel to what is provided.
	rpc Set(ACL.List) returns(Void);

	// GetEffectivePermissions returns the effective permissions for the given
	// user in the given channel.
	rpc GetEffectivePermissions(ACL.Query) returns(ACL);

	// AddTemporaryGroup adds a user to a temporary group.
	rpc AddTemporaryGroup(ACL.TemporaryGroup) returns(Void);
	// RemoveTemporaryGroup removes a user from a temporary group.
	rpc RemoveTemporaryGroup(ACL.TemporaryGroup) returns(Void);
}

message Authenticator {
	message Request {
		message Authenticate {
			optional string name = 1;
			optional string password = 2;
			repeated bytes certificates = 3;
			optional string certificate_hash = 4;
			optional bool strong_certificate = 5;
			// TODO(grpc): include IP address?
		}

		message Query {
			optional uint32 id = 1;
			optional string name = 2;
		}

		message Register {
			optional DatabaseUser user = 1;
		}

		message Deregister {
			optional DatabaseUser user = 1;
		}

		message Update {
			optional DatabaseUser user = 1;
		}

		optional Authenticate authenticate = 1;
		optional Query query = 2;
		optional Register register = 3;
		optional Deregister deregister = 4;
		optional Update update = 5;
	}

	message Response {
		message Initialize {
			optional Server server = 1;
			// TODO(grpc): optional bool updating = 2;
		}

		enum Status {
			Success = 0;
			Failure = 1;
			Fallthrough = 2;
			TemporaryFailure = 3;
		}

		message Authenticate {
			optional Status status = 1;
			optional uint32 id = 2;
			optional string name = 3;
			//repeated string groups = 4; // TODO(grpc): ACL.Group?
			// TODO(grpc): is groups really needed? Can't we just call
			// ACLService.AddTemporaryGroup? Will need to pass the session/User object
			// to the authenticator for this to happen.
		}

		message Query {
			repeated DatabaseUser users = 1;
		}

		message Register {
			optional Status status = 1;
			optional DatabaseUser user = 2;
		}

		message Deregister {
			optional Status status = 1;
		}

		message Update {
			optional Status status = 1;
		}

		optional Initialize initialize = 1;
		optional Authenticate authenticate = 2;
		optional Query query = 3;
		optional Register register = 4;
		optional Deregister deregister = 5;
		optional Update update = 6;
	}
}

service AuthenticatorService {
	rpc Stream(stream Authenticator.Response) returns(stream Authenticator.Request);
}

message DatabaseUser {
	optional Server server = 1;

	optional uint32 id = 2;
	optional string name = 3;
	optional string email = 4;
	optional string comment = 5;
	optional string hash = 6;
	optional string password = 7;
	optional string last_active = 8;
	optional bytes texture = 9;

	message Query {
		optional Server server = 1;

		optional string filter = 2;
	}

	message List {
		optional Server server = 1;

		repeated DatabaseUser users = 2;
	}

	message Verify {
		optional Server server = 1;

		optional string name = 2;
		optional string password  = 3;
	}
}

service DatabaseService {
	// Query returns a list of registered users who match given query.
	rpc Query(DatabaseUser.Query) returns(DatabaseUser.List);
	// Get returns the database user with the given id.
	rpc Get(DatabaseUser) returns(DatabaseUser);
	// Update updates the given database user.
	rpc Update(DatabaseUser) returns(Void); // TODO(grpc): should the updated user be returned?
	// Register registers a user with the given information on the server. The
	// returned DatabaseUser will contain the newly registered user's ID.
	rpc Register(DatabaseUser) returns(DatabaseUser);
	// Deregister deregisters the given user.
	rpc Deregister(DatabaseUser) returns(Void);
	// Verify verifies the that the given user-password pair is correct.
	rpc Verify(DatabaseUser.Verify) returns(DatabaseUser);
}

message RedirectWhisperGroup {
	optional Server server = 1;

	optional User user = 2;
	optional string source = 3; // TODO(grpc): should be ACL.Group?
	optional string target = 4; // TODO(grpc): should be ACL.Group?
}

service AudioService {
	// SetRedirectWhisperGroup redirects whisper targets for the given user.
	// Whenever a user tries to whisper to group "source", the whisper will be
	// redirected to group "target". Omitting "target" will remove the redirect.
	rpc SetRedirectWhisperGroup(RedirectWhisperGroup) returns(Void);
	// TODO(grpc): convert to AddRedirectWhisperGroup + RemoveRedirectWhisperGroup?
}
